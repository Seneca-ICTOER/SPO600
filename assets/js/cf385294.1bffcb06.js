"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[6064],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(n),h=a,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return n?r.createElement(m,s(s({ref:t},u),{},{components:n})):r.createElement(m,s({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5869:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return i},toc:function(){return c}});var r=n(3117),a=(n(7294),n(3905));const o={id:"6502-instructions-introduction",title:"6502 Instructions - Introduction",sidebar_position:4,description:"6502 Instructions - Introduction"},s="6502 Instructions - Introduction",i={unversionedId:"G-6502/6502-instructions-introduction",id:"G-6502/6502-instructions-introduction",title:"6502 Instructions - Introduction",description:"6502 Instructions - Introduction",source:"@site/docs/G-6502/6502-instructions-introduction.md",sourceDirName:"G-6502",slug:"/G-6502/6502-instructions-introduction",permalink:"/SPO600/G-6502/6502-instructions-introduction",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/G-6502/6502-instructions-introduction.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"6502-instructions-introduction",title:"6502 Instructions - Introduction",sidebar_position:4,description:"6502 Instructions - Introduction"},sidebar:"courseNotesSidebar",previous:{title:"6502 Addressing Modes",permalink:"/SPO600/G-6502/6502-addressing-modes"},next:{title:"6502 Math",permalink:"/SPO600/G-6502/6502-math"}},l={},c=[{value:"Addressing Modes",id:"addressing-modes",level:2},{value:"Registers",id:"registers",level:2},{value:"Performance",id:"performance",level:2},{value:"Instructions by Category",id:"instructions-by-category",level:2},{value:"Loading and Storing Data (to/from Memory)",id:"loading-and-storing-data-tofrom-memory",level:3},{value:"Register-Memory Loads and Stores",id:"register-memory-loads-and-stores",level:4},{value:"Push/Pull on the Stack",id:"pushpull-on-the-stack",level:4},{value:"Transferring Data between Registers",id:"transferring-data-between-registers",level:4},{value:"Arithmetic and Bitwise Operations",id:"arithmetic-and-bitwise-operations",level:3},{value:"Test and Comparison Operations",id:"test-and-comparison-operations",level:3},{value:"Program Flow",id:"program-flow",level:3},{value:"Unconditional Jump",id:"unconditional-jump",level:4},{value:"Jump to SubRoutine",id:"jump-to-subroutine",level:4},{value:"Conditional Branch",id:"conditional-branch",level:4},{value:"Manipulating Flags",id:"manipulating-flags",level:3},{value:"Miscellaneous Instructions",id:"miscellaneous-instructions",level:3},{value:"Resources",id:"resources",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"6502-instructions---introduction"},"6502 Instructions - Introduction"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502"},"6502")," processor has a compact instruction set, consisting of just 56 instructions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"ADC AND ASL BCC BCS BEQ BIT \nBMI BNE BPL BRK BVC BVS CLC  \nCLD CLI CLV CMP CPX CPY DEC\nDEX DEY EOR INC INX INY JMP\nJSR LDA LDX LDY LSR NOP ORA\nPHA PHP PLA PLP ROL ROR RTI \nRTS SBC SEC SED SEI STA STX\nSTY TAX TAY TSX TXA TXS TYA\n")),(0,a.kt)("p",null,"This page groups these instructions into functional categories and explains their basic purpose."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Addressing Modes and Registers are essential!:")," Take the time to understand the ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502-addressing-modes"},"6502 addressing modes")," and ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502#registers"},"registers"),". This is essential background infromation for understanding the 6502 instructions."),(0,a.kt)("h2",{id:"addressing-modes"},"Addressing Modes"),(0,a.kt)("p",null,"There are thirteen ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502-addressing-modes"},"6502 Addressing Modes"),". All of these instructions work with at least one addressing mode, and many work with several addressing modes. See the ",(0,a.kt)("a",{parentName:"p",href:"#resources"},"Resources")," section for Opcode tables that define which instructions work with which addressing modes."),(0,a.kt)("h2",{id:"registers"},"Registers"),(0,a.kt)("p",null,"Most of these instructions work with ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/E-ComputerArchitecture/register"},"registers"),". Refer to the ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502#registers"},"6502 page, Register section")," for details on the 6502's internal registers."),(0,a.kt)("h2",{id:"performance"},"Performance"),(0,a.kt)("p",null,"Each 6502 instruction takes a defined number of machine cycles to execute. In some cases,the number of cycles will vary depending on the circumstances of the instruction's execution - for example, the conditional branch instruction ",(0,a.kt)("inlineCode",{parentName:"p"},"BRE")," (Branch if EQual) takes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"2 cycles if the branch is not taken"),(0,a.kt)("li",{parentName:"ul"},"3 cycles if a branch is taken to an address in the same page"),(0,a.kt)("li",{parentName:"ul"},"4 cycles if a branch is taken to an address in another page")),(0,a.kt)("p",null,"Remember that the Program Counter (PC register) contains a pointer to the next instruction to be executed. When the BEQ instruction has been loaded into the CPU, the PC points to the instruction following the BEQ. The branch works by adding a signed integer value (in the range of -128 to +127) to the Program Counter; the extra cycle required when the branch is taken is used to process the addition. If the high byte of the Program Counter changes (because the branch crosses in to another page), one additional cycle is required to adjust the high byte."),(0,a.kt)("p",null,"You can find the execution time in the instruction charts found in the ",(0,a.kt)("a",{parentName:"p",href:"#resources"},"Resources")," section below."),(0,a.kt)("p",null,"To convert the number of cycles to time, multiply the cycles by the time between system ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/E-ComputerArchitecture/clock"},"clock")," pulses. Many 6502 systems operated at 1 MHz (1 million operations per second), and therefore 1 cycle corresponded to 1 millionth of a second, or 1 microsecond (uS). Therefore, an instruction that took 4 clock cycles would take 4 uS to execute."),(0,a.kt)("h2",{id:"instructions-by-category"},"Instructions by Category"),(0,a.kt)("h3",{id:"loading-and-storing-data-tofrom-memory"},"Loading and Storing Data (to/from Memory)"),(0,a.kt)("h4",{id:"register-memory-loads-and-stores"},"Register-Memory Loads and Stores"),(0,a.kt)("p",null,"There are three instructions to load data from memory to a register:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA ; load the accumulator\nLDX ; load the X register \nLDY ; load the Y register\n")),(0,a.kt)("p",null,"And there are three matching instructions to store data from a register to a memory location:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"STA ; store the accumulator \nSTX ; store the X register \nSTY ; store the Y register\n")),(0,a.kt)("h4",{id:"pushpull-on-the-stack"},"Push/Pull on the Stack"),(0,a.kt)("p",null,"When a value is pushed to the stack, the stack pointer register (SP) is decremented and the selected register is written to memory location $0100+SP."),(0,a.kt)("p",null,"When a value is pulled from the stack, the stack pointer register (SP) is incremented and the selected register is loaded from memory location $0100+SP."),(0,a.kt)("p",null,"There are two instructions to push data onto the stack:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"PHA ; push the accumulator\nPHP ; push the processor status register (SR)\n")),(0,a.kt)("p",null,"And two matching instructions to pull data from the stack:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"PLA ; pull the accumulator\nPLP ; pull the processor status register (SR)\n")),(0,a.kt)("p",null,"Note that some other operations, such as JSR, interrupts, RTI, and RTS, cause data to be pushed to or pulled from the stack."),(0,a.kt)("h4",{id:"transferring-data-between-registers"},"Transferring Data between Registers"),(0,a.kt)("p",null,"The X and Y registers can be transferred to/from the accumulator:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"TAX ; transfer A to X\nTAY ; transfer A to Y\nTXA ; transfer X to A\nTYA ; transfer Y to A\n")),(0,a.kt)("p",null,"You can also transfer the Stack Pointer (SP) to/from the X register:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"TSX ; transfer SP to X\nTXS ; tranfer X to SP\n")),(0,a.kt)("p",null,"It is not possible to directly transfer the Status Register (SR) to a general-purpose register, but you can you transfer it via the stack (e.g., by pushing SR to the stack with with ",(0,a.kt)("inlineCode",{parentName:"p"},"PHP")," and then popping the stack to the accumulator with ",(0,a.kt)("inlineCode",{parentName:"p"},"PLA"),")."),(0,a.kt)("h3",{id:"arithmetic-and-bitwise-operations"},"Arithmetic and Bitwise Operations"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Watch the Carry Flag!:")," Failing to clear the carry flag before addition or to set the carry flag before subtraction is the cause of many bugs in 6502 programs. The carry flag also affects the rotate instructions. Be sure to set or clear this flag with the ",(0,a.kt)("inlineCode",{parentName:"p"},"SEC")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"CLC")," instructions when needed!"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"For full details on all of the arithmetic and bitwise instructions, see the ",(0,a.kt)("a",{parentName:"strong",href:"/SPO600/G-6502/6502-math"},"6502 Math")," page.")),(0,a.kt)("p",null,"The 6502 has rudimentry addition and subtraction instructions, which operate on the accumulator (A):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"ADC ; add with carry\nSBC ; subtract with carry\n")),(0,a.kt)("p",null,"There are also increment and decrement instructions for the X and Y registers and for memory:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"DEC ; decrement memory\nDEX ; decrement X register\nDEY ; decrement Y register\n\nINC ; increment memory\nINX ; increment X register\nINY ; increment Y register\n")),(0,a.kt)("p",null,"The 6502 also has instructions for left and right bit-shifts and rotations (which can act as multiply-by-2 and divide-by-2):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"ASL ; arithmetic shift left\nROL ; rotate left\n\nLSR ; logical shift right\nROR ; rotate right\n")),(0,a.kt)("p",null,"There are also instructions for bitwise operations such as exclusive-OR, OR, and AND. Exclusive-OR with #$FF is equivalent to a NOT operation, and these operations can be combined to produce other logical operations such as NOR and NAND."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"AND ; bitwise AND (with accumulator)\nEOR ; bitwise exclusive-OR (with accumulator)\nORA ; bitwise OR (with accumulator)\n")),(0,a.kt)("h3",{id:"test-and-comparison-operations"},"Test and Comparison Operations"),(0,a.kt)("p",null,"The A, X, and Y registers can be directly compared with immediate or memory values:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"CMP ; compare (accumulator)\nCPX ; compare (X register)\nCPY ; compare (Y register)\n")),(0,a.kt)("p",null,"These operations are performed by subtraction. The appropriate condition flags are set, and the result of the subtraction is discarded. Conditional branch instructions can be used to alter program flow based on the results of the comparisons."),(0,a.kt)("p",null,"There is another test instruction available:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"BIT ; bit test\n")),(0,a.kt)("p",null,"This instruction places bit 7 of the operand into the N flag and bit 6 of the operand into the V flag. The operand is then ANDed with the accumulator, and the Z flag is set if the result is zero. The result of the AND is discarded. In this way, you can test the value of bit 7, bit 6, or any arbitrary bits (using the operand)."),(0,a.kt)("p",null,"Note that in addition to these instructions, many other instructions (such as register loads) affect condition flags."),(0,a.kt)("h3",{id:"program-flow"},"Program Flow"),(0,a.kt)("h4",{id:"unconditional-jump"},"Unconditional Jump"),(0,a.kt)("p",null,'An unconditional jump is like a "Goto" -- it sets the address of the next instruction to be executed (by modifying the Program Counter (PC)):'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"JMP ; jump to address\n")),(0,a.kt)("h4",{id:"jump-to-subroutine"},"Jump to SubRoutine"),(0,a.kt)("p",null,"A jump to a subroutine is also unconditional, but the current value of the Program Counter (PC) is placed on the stack so that when the subroutine (aka procedure, function, or method) is finished, execution can resume at the instruction after the jump to subroutine:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"JSR ; jump to subroutine (pushes PC on stack, loads operand into PC)\nRTS ; return from subroutine (pops PC from stack)\n")),(0,a.kt)("h4",{id:"conditional-branch"},"Conditional Branch"),(0,a.kt)("p",null,"A conditional branch is like a jump, except that it is only performed if a certain condition is met:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"BCC ; branch on carry clear (C flag is clear)\nBCS ; branch on carry set (C flag is set)\nBEQ ; branch if equal (Z flag is set)\nBMI ; branch if minus (N flag is set)\nBNE ; branch if not equal (Z flag is clear)\nBPL ; branch if plus (N flag is clear)\nBVC ; branch if overflow clear (V flag is clear)\nBVS ; branch if overflow set (V flag is set)\n")),(0,a.kt)("p",null,"Note that the operand for conditional branch instructions is a relative offset - a signed 8-bit value (in the range -128 to +127) that is added to the current PC. When writing assembler (or viewing disassembled code), the operand is ",(0,a.kt)("em",{parentName:"p"},"written")," as an absolute address or label, but the actual ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/E-ComputerArchitecture/machine-language"},"machine language")," code uses the relative addressing mode. For this reason, a branch that is too far will not assemble and will produce an error message."),(0,a.kt)("h3",{id:"manipulating-flags"},"Manipulating Flags"),(0,a.kt)("p",null,"The 6502 provides instructions for setting and clearing various condition flags:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"CLC ; clear carry flag (C) - required before using ADC\nCLD ; clear decimal flag (D) - switches into binary math mode\nCLI ; clear interrupt disable (I) - enables processor interrupts\nCLV ; clear overflow flag (V)\n\nSEC ; set carry flag (C) - required before using SBC\nSED ; set decimal flag (D) - switches into decimal math mode\nSEI ; set interrupt disable - turns off processor interrupts\n")),(0,a.kt)("p",null,"Note that there is no instruction to set the overflow (V) flag."),(0,a.kt)("h3",{id:"miscellaneous-instructions"},"Miscellaneous Instructions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},'BRK ; "BREAK" - turn control over to the debugger\n')),(0,a.kt)("p",null,'This instruction initiates a special version of the Non-Maskable Interrupt - "Non-maskable" meaning that the interrupt flag (I) cannot disable this signal.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"RTI ; return from interrupt\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"RTI")," is very similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"RTS")," (ReTurn from Subroutine), but is used to return from interrupts."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"NOP ; no operation\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"NOP"),' instruction does nothing. It can be used to "comment-out" code.'),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("p",null,"These resources provide detailed summaries of the 6502 instructions, including the number of cycles required to execute the instructions, flags affected by each instruction, and the addressing modes available:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"http://www.6502.org/tutorials/6502opcodes.html"},"6502 Opcodes with Register Definitions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.masswerk.at/6502/6502_instruction_set.html"},"6502 Opcodes with Detailed Operation Information"))))}d.isMDXComponent=!0}}]);