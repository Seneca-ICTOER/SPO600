<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-E-ComputerArchitecture/computer-architecture">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-rc.1">
<link rel="icon" href="/SPO600/img/pwa/icon-512x512.png">
<link rel="manifest" href="/SPO600/manifest.json">
<meta name="theme-color" content="#DA291C">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#DA291C">
<link rel="apple-touch-icon" href="/SPO600/img/pwa/icon-192x192.png">
<link rel="mask-icon" href="/SPO600/img/pwa/icon-512x512.png" color="#DA291C">
<meta name="msapplication-TileImage" content="/SPO600/img/pwa/icon-512x512.png">
<meta name="msapplication-TileColor" content="#DA291C">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><title data-rh="true">Computer Architecture | SPO600 - Software Portability and Optimization</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://Seneca-ICTOER.github.io//SPO600/E-ComputerArchitecture/computer-architecture"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Computer Architecture | SPO600 - Software Portability and Optimization"><meta data-rh="true" name="description" content="Computer Architecture"><meta data-rh="true" property="og:description" content="Computer Architecture"><link data-rh="true" rel="icon" href="/SPO600/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://Seneca-ICTOER.github.io//SPO600/E-ComputerArchitecture/computer-architecture"><link data-rh="true" rel="alternate" href="https://Seneca-ICTOER.github.io//SPO600/E-ComputerArchitecture/computer-architecture" hreflang="en"><link data-rh="true" rel="alternate" href="https://Seneca-ICTOER.github.io//SPO600/E-ComputerArchitecture/computer-architecture" hreflang="x-default"><link rel="stylesheet" href="/SPO600/assets/css/styles.099fe1a9.css">
<link rel="preload" href="/SPO600/assets/js/runtime~main.313ff0ae.js" as="script">
<link rel="preload" href="/SPO600/assets/js/main.48ab27b2.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><a class="navbar__brand" href="/SPO600/"><div class="navbar__logo"><img src="/SPO600/img/logo.svg" alt="Seneca College" class="themedImage_ToTc themedImage--light_HNdA"><img src="/SPO600/img/logo-dark.svg" alt="Seneca College" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">SPO600 - Software Portability and Optimization</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/SPO600/">Welcome to SPO600</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/SPO600/weekly-schedule">Weekly Schedule</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/SPO600/A-Classes/week1-class1">Classes</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/SPO600/B-Labs/lab1">Labs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/SPO600/C-Projects/project">Projects</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/SPO600/D-ExtraResources/course-policies">Extra Resources</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/SPO600/E-ComputerArchitecture/computer-architecture">Computer Architecture</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/SPO600/E-ComputerArchitecture/computer-architecture">Computer Architecture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/address">Address</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/addressing-mode">Addressing Mode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/assembler">Assembler</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/atomic-operation">Atomic Operation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/bcd">BCD</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/bitwise-operations">Bitwise Operations</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/clock">Clock</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/compiler-intrinsics">Compiler Intrinsics</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/compiler">Compiler</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/debugger">Debugger</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/disassembler">Disassembler</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/endian">Endian</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/expensive">Expensive</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/flags">Flags</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/ieee-754">IEEE 754</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/immediate-value">Immediate Value</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/instruction-encoding">Instruction Encoding</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/instruction-set-architecture">Instruction Set Architecture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/instruction">Instruction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/machine-language">Machine Language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/memory-prefetch">Memory Prefetch</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/opcode">OpCode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/operation">Operation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/portable">Portable</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/register">Register</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/signed">Signed</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/stack">Stack</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/truth-table">Truth Table</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/volatile">Volatile</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/SPO600/E-ComputerArchitecture/word">Word</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/SPO600/F-AssemblyLanguage/assembly-language">Assembly Language</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/SPO600/H-ARM/armv8">ARM</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/SPO600/G-6502/6502">6502</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/SPO600/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Computer Architecture</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Computer Architecture</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Computer Architecture</h1><p>The phrase <em>Computer Architecture</em> refers to the design of a computer, primarily focused on the central processing unit but also including main memory and input-output (IO) subsystems. The term &quot;architecture&quot; is generally used to refer to the core components of the system and not peripheral devices.</p><p><strong>Introduction Only:</strong> This page is intended as an introduction to some computer architecture concepts only. It is not a comprehensive text on computer architecture! Please be sure to review the other entries in the Computer Architecture Menu on the left side and class notes.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="common-elements-in-modern-computer-design">Common Elements in Modern Computer Design<a class="hash-link" href="#common-elements-in-modern-computer-design" title="Direct link to heading">​</a></h2><p>Various decisions made throughout the history of computing have resulted in a fairly consistent basic design for most modern digital computers: almost all designs consist of:</p><ul><li>A central processing unit (CPU) which reads binary <a href="/SPO600/E-ComputerArchitecture/machine-language">machine language</a> instructions from memory and executes them. The CPU contains multiple <a href="/SPO600/E-ComputerArchitecture/register">registers</a>. Instructions are executed according to a <a href="/SPO600/E-ComputerArchitecture/clock">clock</a> pulse, which synchronizes activity across the system.</li><li>Memory, including random-access memory (RAM), which consists of multiple <a href="/SPO600/E-ComputerArchitecture/word">words</a> of memory which are individually <a href="/SPO600/E-ComputerArchitecture/address">addressable</a> -- words can be individually written to or read from each address. Memory is used to store both instructions and data. Memory is generally <a href="/SPO600/E-ComputerArchitecture/volatile">volatile</a>, but some non-volatile memory is usually provided for system startup.</li><li>Some memory is connected to the CPU as well as one or more devices for &quot;memory mapped&quot; input/output -- the CPU as one device, and a peripheral such as a video system or disk controller as the second device. Most modern computers use a <a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture" target="_blank" rel="noopener noreferrer">Von Neuman</a> architecture, with one memory space for both instructions (software) and data. In some systems, devices may be accessed through a separate address range (designated for I/O ports), which acts like memory-mapped I/O but has a distinct addressing scheme. Devices can get the CPU&#x27;s attention using an <a href="#interrupts-and-exceptions">Interrupt</a> scheme. Devices include:<ul><li>Storage, which is addressable in sectors or blocks, and is used for <a href="/SPO600/E-ComputerArchitecture/volatile">non-volatile</a>, long-term storage of instructions and data.</li><li>Human interface devices (HID), such as keyboards, pointing devices (mice, touchscreens, trackpads, and so forth), and fingerprint readers. These are typically low-speed devices (e.g., people type at 6 characters per second or less).</li><li>Video, which typically uses a region of memory as a framebuffer to store the image being displayed. The video system may also be able to perform hardware-accelerated operations such as bit-blitting, fills, video overlays, and 3D operations.</li><li>Audio, which typically uses a region of memory as an audio sample buffer.</li><li>Connectivity, including network, serial, and radio (including WiFi and Cellular) connections.</li></ul></li></ul><p>However, there is an enormous amount of variation even within this general design.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="popular-architecture-families">Popular Architecture Families<a class="hash-link" href="#popular-architecture-families" title="Direct link to heading">​</a></h2><p>Throughout this page and the Computer Architecture folder on the left side, several architecture families are mentioned, including:</p><ul><li>x86 - The Intel/AMD architecture which debuted with the Intel 8086 processor (16-bit), gained desktop and server dominance as the 386/486/x86 32-bit architecture, and was extended by AMD to the 64-bit x86_64 architecture. Intel and AMD vigorously compete with x86_64 CPUs, which continue as the preeminent server architecture and most popular desktop architecture.</li><li>ARM - An architecture which started with the Acorn computer company, became the dominant mobile and embedded architecture in its 32-bit incarnations, and was extended to 64-bit in version 8 (<a href="/SPO600/H-ARM/armv8">ARMv8</a>) with the <a href="/SPO600/H-ARM/armv8">AArch64</a> mode. 64-bit ARM processors are dominant in smartphone applications and starting to be compete in server and high-performance computing systems.</li><li>PowerPC - An architecture which has been used in a wide range of applications, from Apple desktop systems to Sony PlayStation CELL processors, and which is now used primarily in IBM midrange and mainframe systems.</li><li>MIPS - An architecture which was used in Sillicon Graphics workstations but has found its primary audience in network infrastructure such as backbone routers and firewall systems.</li></ul><p>As well as some architectures which are no longer current:</p><ul><li>6502 - An 8-bit architecture which helped spawned the home computing/personal computing era.</li><li>Sparc - A RISC architecture developed by Sun Microsystems which powered the high-end workstation and server market for many years.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="basic-cpu-features">Basic CPU Features<a class="hash-link" href="#basic-cpu-features" title="Direct link to heading">​</a></h2><p>There are many variables in CPU design, including:</p><ul><li><strong>Register width</strong> - <a href="/SPO600/E-ComputerArchitecture/register">Registers</a> are generally fixed-width, with 8, 16, 32, and 64 bit widths common (though other values are sometimes seen). Some CPUs have multiple registers of different sizes, or can access smaller subsets of larger registers (e.g., accessing the first 8 bits of a 64-bit register when needed), or can access a register as two smaller registers or one larger register (e.g., the 16-bit accumulator register on the 6809E processor can also be accessed as two 8-bit registers). Processors with wider registers are generally considered more powerful, though this may actually be a drawback in some specific situations.</li><li>The <strong>number of registers</strong> varies from three or four to many dozen. Some processors are equipped with multiple sets of registers, and can rapidly switch between the register sets on demand (e.g., Intel &quot;Hyperthreading&quot; technology), which simplifies and speeds up process or thread switches. Since registers are often significantly faster than RAM, a larger register set is generally considered better, except that it will take longer to save a larger register set when switching processes. The full set of registers available on a CPU is known as the register file.</li><li>The <em>work</em> of a CPU is performed by <strong>Execution Units</strong>, which perform operations such as loading and storing data from/to memory (load/store unit), performing integer math (integer unit), executing <a href="/SPO600/E-ComputerArchitecture/bitwise-operations">bitwise operations</a>, and performing floating-point math (floating-point unit, or FPU). The length of time taken to perform an operation varies according to the sophistication of the execution unit and the complexity of the operation. For example, a multiplication can be performed in many different ways, ranging from repeated addition (very slow, but requiring very little hardware logic) to table lookup (very fast, but requiring a lot of silicon), with most implementations falling somewhere in the middle. A multiplication will almost always take longer to perform than an addition, and may vary according to carry and overflow sub-operations required. The use of multiple units permits faster operations to be completed on some execution units while other (slower) operations are taking place on other execution units.</li><li>As instructions are performed, special results are recorded as <a href="/SPO600/E-ComputerArchitecture/flags">flags</a> within the CPU. For example, adding or multiplying two numbers will set a &quot;Carry&quot; flag when the result overflows the word width. Other flags may indicate zero or negative result values. These flags can then be used in later operations -- for example, a branch may be taken if the carry flag is set. The number of flags, their specific meanings, and the circumstances under which they are set (to binary &quot;1&quot;) and cleared (to binary &quot;0&quot;) vary from architecture to architecture.</li><li><strong>Cache</strong> is high-speed memory placed between RAM and the CPU. This memory is faster than main RAM but much smaller; it improves performance by enabling the CPU to continue to write data quickly and continue without waiting for the data to be written out to main RAM. It also provides fast access to instructions or data that are accessed repeatedly, such as when a small loop is being executed. The performance difference between a loop that fits into cache and a loop that does not fit into cache can be substantial. Cache memory is arranged in &quot;lines&quot; which are typically a multiple of the word size; requesting a memory address that is not in cache results in a &quot;cache miss&quot; which causes a stall while the cache contents are retrieved from main memory. Cache design varies in many details, especially in write behaviour -- the cache can simply carry a write through to main memory (write-through), or it can hold the data in cache and write it back at a later time (write-back). There may be multiple levels of cache of varying sizes.</li><li><strong>Pre-fetching</strong> is the process of retrieving instructions from memory before executing them. Done effectively, this avoids pipeline stalls due to cache misses.</li><li><strong>Branch prediction</strong> is used to guess whether a branch will be taken or not taken based on past history. For example, in most loops, the same branch is taken repeatedly until the loop exit condition is met, so a prediction that the loop will be taken will be correct most of the time. However, inside the loop, there may be a conditional statement (&quot;if&quot;) which is usually executed, so predicting that the branch that skirts around the conditional code will not be taken will be correct most of the time. Branch prediction is used in conjunction with pre-fetching and pipelining to improve performance.</li><li><strong>Pipelining</strong> is the sequential decoding and execution of an instruction. As each instruction is passed through the stages of a pipeline, other instructions can be processed by other stages. However, when a conditional branch appears, a decision must be made before the conditional branch can be evaluated: should the pipeline be filled with the instructions that are on the code path associated with taking the branch, or with not taking the branch? In either case, if the wrong branch prediction is made, then the contents of the entire pipeline must be discarded. The pipeline can be stalled if an execution unit is not available when needed or if a memory read or write is stalled by cache. Execution based on branch prediction is called speculative execution.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="memory-design">Memory Design<a class="hash-link" href="#memory-design" title="Direct link to heading">​</a></h2><p>In addition to cache, briefly described above, most modern computer systems use some type of paged memory design, memory maps, and a memory management unit (MMU) to control memory.</p><p>Effectively, memory is divided into &quot;pages&quot; of a set size (such as 4KB, 1MB, or 4MB). These pages are <em>mapped</em> using a memory mapping table or address translation table, which renumbers the addresses of the locations within that page. Pages which do not appear in the memory map are not accessible to the CPU. It is also possible to mark specific attributes for each page in the mapping table, such as &quot;do not execute&quot; and &quot;read only&quot;.</p><p>For example, a computer may have three processes, &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;. Only one process is active at a time (assuming a single-core model), and the operating system switches between the processes frequently whenever they are eligible to run to create the appearance of concurrent execution. (A program is not eligible to run if it is blocked by something -- for example, when it is waiting for data from the disk, network, or keyboard, and that data hasn&#x27;t arrived yet).</p><p>Process A and B are running two separate programs, so the memory map is set so that the pages used by the first program are visible when process A is running; pages used for the data used by that process are also made visible. The memory map is changed so that the pages of the second program and data space are visible when process B is running. Neither process can access the software or data of the other program.</p><p>Process B and C may be executing the same program. In this case, the memory map active while each process is running contains the same program, but different data pages. The program is only loaded into memory once, reducing memory requirements.</p><p>Advanced use of the MMU by the operating system enables features such as virtual memory (pages which are not in use are placed in storage (on disk) until required), demand-loading (pages of data or software are only retrieved from disk into memory when they are accessed for the first time), and copy-on-write (two processes access a copy of the same data page, until one of them writes to the page, at which point the operating system makes a copy of the page and sets up each process to access their own copy - which gives the same result as having two private copies of the page, without using additional memory until absolutely necessary; this is commonly used with a fork() system call).</p><p>The cache size and type, page size, levels of memory maps (one to three levels of indirection are common), and page attributes vary significantly between computer architectures.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="execution-state-priviledge-state-rings-or-privilege-level">Execution State, Priviledge State, Rings, or Privilege Level<a class="hash-link" href="#execution-state-priviledge-state-rings-or-privilege-level" title="Direct link to heading">​</a></h2><p>Most processors have multiple privilege levels so that certain instructions can only be executed by certain software. On a modern system, this typically includes a hypervisor level (for virtual machine management), operating system level, and user level, and the names and number of levels vary. The higher-privilege modes can set up memory maps and access devices which are not available to lower-privilege levels; this forces certain operations to be performed by the operating system or hypervisor so that security policies can be enforced.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interrupts-and-exceptions">Interrupts and Exceptions<a class="hash-link" href="#interrupts-and-exceptions" title="Direct link to heading">​</a></h2><p>Hardware interrupt requests (IRQs) are external signals which cause the CPU to stop executing the current program (generally between instructions) and jump to a pre-defined block of code. These signals were originally dedicated electrical signals but in newer systems may take the form of serially-signalled data (for example, on a PCIe bus). An interrupt is typically used to make the operating system service I/O requests when they occur. For example, when a sector of data is available from a disk drive, the disk controller will trigger an interrupt on the CPU, which will cause the operating system to load the received data. This may then cause the operating system to change the status of a process from blocked (waiting for data) to eligible for execution, so that it will be considered along with all other eligible processes when the next process switch is performed.</p><p>Most architectures support multiple levels of interrupts, usually numbered (e.g., &quot;IRQ0&quot;, &quot;IRQ8&quot;, and so forth). These may be handled by the CPU itself, or a (programmable) interrupt controller (<em>PIC</em>, <em>APIC</em>, or <em>GIC</em>) may latch the IRQ event and signal the processor, which then queries the interrupt controller to determine which interrupt occurred. Some architectures support multiple types or priorities of interrupts -- for example, the 6502 supports regular (IRQ) and higher-priority non-maskable interrupts (NMI), while ARM processors offer both regular (IRQ) and &quot;fast&quot; interrupts (FIQ).</p><p>Software interrupts are similar to hardware interrupts, but are triggered by a specific instruction. x86, ARM, and PPC processors use software interrupts to invoke system calls.</p><p>An interrupt handler is part of the operating system typically runs at a higher privilege level than a regular application.</p><p>Exceptions (or <em>traps</em>) are similar to interrupts, but are triggered by event occurrences within the processor. These exceptions cause code within the operating system to be executed to handle the event. Events which will trigger an exception include:</p><ul><li>Accessing a memory location which is not mapped. This will cause the operating system to swap-in a virtual memory page, load a binary page on-demand, or signal a segmentation fault (segfault)/general protection fault (gpf) depending on the circumstances.</li><li>Writing to a read-only page, which will cause a copy-on-write or segfault/gpf depending on circumstances.</li><li>Division by zero.</li><li>Attempted execution of a protected instruction. Some operations can only be used when the CPU is in a particular mode -- for example, MMU address translation tables can only be altered by the operating system kernel, not by a regular process.</li><li>Attempted execution of an undefined or invalid instruction.</li></ul><p>When any type of interrupt is received, the <a href="/SPO600/E-ComputerArchitecture/register#program-counter">program counter</a> is saved (typically by pushing it on the <a href="/SPO600/E-ComputerArchitecture/stack">stack</a> or storing it in a dedicated register), and then a new value for the program counter is loaded from an <em>interrupt vector</em> stored in a register or a pre-defined memory location, usually at the top or bottom of physical <a href="/SPO600/E-ComputerArchitecture/address">address space</a>. Effectively, this means that a subroutine jump is performed to the interrupt-handling routine. In systems where multiple devices are connected to one hardware interrupt line, it is necessary to poll the PIC/APIC or the attached devices to determine which one(s) triggered the interrupt before servicing the request(s). When the interrupt routine exits, the original program counter location is restored, and execution of the interrupted program continues.</p><p>Most but not all interrupts can be masked -- temporarily turned off -- either in the CPU or in the PIC/APIC/GIC.</p><p>Many debugging tools use a software interrupt for single-stepping through a program - for example, on a 6502, the instruction after the one to be executed by single-stepping is replaced with a BRK instruction (opcode 00), so that control will immediately return to the debugger after one instruction is executed. In other cases, the debugger regains control by scheduling a timer-based hardware non-maskable interrupt (NMI) to occur during the execution of the next instruction, using a peripheral timer chip.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="multiple-cores">Multiple Cores<a class="hash-link" href="#multiple-cores" title="Direct link to heading">​</a></h2><p>Many modern CPU chips have multiple cores. Each core effectively acts like an independent CPU. The most common arrangement of cores is symmetric multiprocessing (SMP), where each core has exactly the same view of physical memory. Special logic in the cache controller ensures that the caches for each core are kept in sync -- otherwise, one core could change data in memory, and another core would not be aware of the change because of stale data in cache. Additional logic arbitrates access to shared resources such as main memory and I/O ports, and routes IRQs</p><p>There are alternatives to SMP, including non-uniform memory access (NUMA).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="in-order-and-out-of-order-execution">In-order and Out-of-order Execution<a class="hash-link" href="#in-order-and-out-of-order-execution" title="Direct link to heading">​</a></h2><p>In-order execution means that instructions are executed in the order in which they exist in memory. Out-of-order execution is an architecture feature where instructions are re-sequenced by the CPU on-the-fly to produce the same logical result while keeping the execution units as busy as possible.</p><p>For example, when evaluating a compound arithmetic function on a CPU that has two units capable of addition which take an average of 2 <a href="/SPO600/E-ComputerArchitecture/clock">clock cycles</a> to perform an operation, and a multiplication unit which takes an average of 5 clock cycles to perform an operation, two multiplications in succession will cause a pipeline stall, because the second operation cannot be performed until the first multiplication has completed. With out-of-order execution, additional logic in the early portion of the pipeline could rearrange operations so that some add/subtract operations would be performed between the two multiplications, avoiding the stall (and therefore increasing performance).</p><p>Out-of-order execution requires significant additional hardware logic (chip space) and energy.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="risc-vs-cisc">RISC vs CISC<a class="hash-link" href="#risc-vs-cisc" title="Direct link to heading">​</a></h2><p>RISC stands for <em>Reduced Instruction Set Computer</em> and is a design philosophy favouring a CPU design which executes a small number of simple instructions very quickly. This approach relies on a good compiler to sequence instructions optimally. Since each instruction is simpler, less silicon is required for instruction decoding and execution, and therefore more silicon is devoted to execution units, cache, and registers to improve performance.</p><p>CISC stands for <em>Complex Instruction Set Computer</em> and is an alternate design philosophy which favours a CPU design where each instruction can perform a lot of work. This approach emphasizes chip logic to optimize performance. Additional silicon is needed for features such as instruction resequencing, deep pipelines, and more complex execution units.</p><p>The RISC vs. CISC debate was at its peak in the 1980s and early 1990s. Most modern CPU designs combine elements of both philosophies. For example, ARM processors, which have historically been considered RISC designs, now include out-of-order execution (a CISC feature); x86 processors, traditionally regarded as a CISC design, now feature larger register sets that were originally considered a RISC feature.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="instruction-set-architecture">Instruction Set Architecture<a class="hash-link" href="#instruction-set-architecture" title="Direct link to heading">​</a></h2><p>The <a href="/SPO600/E-ComputerArchitecture/instruction-set-architecture">Instruction Set Architecture</a> is specific to a particular architecture family and therefore dependent on certain architectural features, such as the register set, but independent of other features, such as the cache type -- because the cache type affects performance but not the instructions which can be executed by the CPU.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="sub-word-and-unaligned-access">Sub-word and Unaligned Access<a class="hash-link" href="#sub-word-and-unaligned-access" title="Direct link to heading">​</a></h2><p>Most processors use a <a href="/SPO600/E-ComputerArchitecture/word">word</a> size that is multiple of width of some common data types. However, it is often necessary to access data which is a fraction of this size -- for example, a system with a 32-bit <a href="/SPO600/E-ComputerArchitecture/word#hardware-word">hardware word size</a> that is running applications which use UTF-8 character encoding may often need to read or write single <a href="/SPO600/E-ComputerArchitecture/word#byte">bytes</a> of data. A byte-sized read will cause the CPU to perform a 32-bit read, followed by <a href="/SPO600/E-ComputerArchitecture/bitwise-operations">masking and shifting operations</a> to extract the desired byte from the 32-bit word. A single-byte write operation will cause the CPU to read the existing word, extract the unaffected bits within that word (similar to an <a href="/SPO600/E-ComputerArchitecture/bitwise-operations#and">AND</a> operation), merg in the new value (similar to an <a href="/SPO600/E-ComputerArchitecture/bitwise-operations#or">OR</a> operation), and then write the word back to memory.</p><p>Unaligned memory access causes similar issues. For example, to read a 32-bit value from the byte address 0x2, most 32-bit CPUs will read a 32-bit value starting at byte address 0x0 and perform an AND to extract highest 16 bits, then a shift to move those bits to the lowest 16 bit positions. The CPU will then read a 32-bit value starting at byte address 0x4, perform the equivalent of an <a href="/SPO600/E-ComputerArchitecture/bitwise-operations#and">AND</a> to extract the lowest 16 bits, shift those bits to the highest 16 bit positions, and then OR the high 16 bits and the low 16 bits together into a single 32 bit value. These operations are usually hardware-optimized to occur much faster than the equivalent software operations. (Writing an unaligned 32-bit value is even worse than reading it!)</p><p>Obviously, unaligned access is far slower than aligned access, and should be avoided whenever possible. However, aligning all storage may result in increased memory usage (e.g., aligning 24-bit pixel values on 32-bit boundaries), and some data such as compressed data streams or network packets will almost always contain unaligned data.</p><p>Some processors, such as ARMv5 processors, do not have alignment-fixup hardware, and an unaligned access causes a processor exception. The operating system may ignore the unaligned access (usually leading to incorrect results), stop the program performing the unaligned access, or fix up the access in software and then resume execution of the process which caused the exception.</p><p>On a Linux system, the control file <code>/proc/cpu/alignment</code> controls how the operating system will handle alignment exceptions (on machines which lack alignment-fixup hardware). The possible values are:</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">0 = ignore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1 = warn (via kernel message)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 = fixup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 = fixup + warn</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that even on systems that perform alignment fixups in hardware, unaligned access is <a href="/SPO600/E-ComputerArchitecture/expensive">expensive</a>.</p><p>Note also that the native word size of the CPU may be different from the physical word size of main memory; for example, some 32-bit systems have a 64-, 128-, or 256-bit-wide memory configuration.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="processor-specific-optimizations">Processor-specific Optimizations<a class="hash-link" href="#processor-specific-optimizations" title="Direct link to heading">​</a></h2><p>Code which is optimized for a particular architecture will take advantage of the features of that architecture, such as the full register file. However, the performance may still vary significantly between processor models within that architecture -- for example, a loop that is small enough to fit in the cache of one processor model may not fit inside the smaller cache of another model within the same architecture family. Likewise, a particular instruction sequence may be optimal for one processor model with a particular combination of execution units, but suboptimal for another model with a different set of units. However, the variation from model to model is usually not huge.</p><p>Most modern compilers, such as GCC, enable you to set the overall target architecture, but also permit you to optimize performance for a specific CPU model within that target architecture. For example, with GCC, the <code>-march</code> argument selects the target architecture for the output code and the specific features that may be accessed by that code, while <code>-mtune</code> is used to optimize the performance for a particular CPU variant.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/E-ComputerArchitecture/computer-architecture.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/SPO600/D-ExtraResources/benchmarking"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Benchmarking</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/SPO600/E-ComputerArchitecture/address"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Address</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#common-elements-in-modern-computer-design" class="table-of-contents__link toc-highlight">Common Elements in Modern Computer Design</a></li><li><a href="#popular-architecture-families" class="table-of-contents__link toc-highlight">Popular Architecture Families</a></li><li><a href="#basic-cpu-features" class="table-of-contents__link toc-highlight">Basic CPU Features</a></li><li><a href="#memory-design" class="table-of-contents__link toc-highlight">Memory Design</a></li><li><a href="#execution-state-priviledge-state-rings-or-privilege-level" class="table-of-contents__link toc-highlight">Execution State, Priviledge State, Rings, or Privilege Level</a></li><li><a href="#interrupts-and-exceptions" class="table-of-contents__link toc-highlight">Interrupts and Exceptions</a></li><li><a href="#multiple-cores" class="table-of-contents__link toc-highlight">Multiple Cores</a></li><li><a href="#in-order-and-out-of-order-execution" class="table-of-contents__link toc-highlight">In-order and Out-of-order Execution</a></li><li><a href="#risc-vs-cisc" class="table-of-contents__link toc-highlight">RISC vs CISC</a></li><li><a href="#instruction-set-architecture" class="table-of-contents__link toc-highlight">Instruction Set Architecture</a></li><li><a href="#sub-word-and-unaligned-access" class="table-of-contents__link toc-highlight">Sub-word and Unaligned Access</a></li><li><a href="#processor-specific-optimizations" class="table-of-contents__link toc-highlight">Processor-specific Optimizations</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">SPO600 - Software Portability and Optimization</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/SPO600/">Contents</a></li><li class="footer__item"><a href="#" id="pwa-button" class="footer__link-item" hidden>Install as an App</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Seneca College.</div></div></div></footer></div>
<script src="/SPO600/assets/js/runtime~main.313ff0ae.js"></script>
<script src="/SPO600/assets/js/main.48ab27b2.js"></script>
</body>
</html>