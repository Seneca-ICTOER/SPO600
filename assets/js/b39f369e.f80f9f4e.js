"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[653],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return d}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=c(a),d=l,k=p["".concat(s,".").concat(d)]||p[d]||u[d]||r;return a?n.createElement(k,i(i({ref:t},m),{},{components:a})):n.createElement(k,i({ref:t},m))}));function d(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},6942:function(e,t,a){a.r(t),a.d(t,{assets:function(){return s},contentTitle:function(){return i},default:function(){return u},frontMatter:function(){return r},metadata:function(){return o},toc:function(){return c}});var n=a(3117),l=(a(7294),a(3905));const r={id:"make-and-makefiles",title:"Make and Makefiles",sidebar_position:19,description:"Make and Makefiles"},i="Make and Makefiles",o={unversionedId:"D-ExtraResources/make-and-makefiles",id:"D-ExtraResources/make-and-makefiles",title:"Make and Makefiles",description:"Make and Makefiles",source:"@site/docs/D-ExtraResources/make-and-makefiles.md",sourceDirName:"D-ExtraResources",slug:"/D-ExtraResources/make-and-makefiles",permalink:"/SPO600/D-ExtraResources/make-and-makefiles",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/D-ExtraResources/make-and-makefiles.md",tags:[],version:"current",sidebarPosition:19,frontMatter:{id:"make-and-makefiles",title:"Make and Makefiles",sidebar_position:19,description:"Make and Makefiles"},sidebar:"courseNotesSidebar",previous:{title:"Overview of the Build and Release Process",permalink:"/SPO600/D-ExtraResources/overview-of-the-build-and-release-process"},next:{title:"Link Time Optimization",permalink:"/SPO600/D-ExtraResources/link-time-optimization"}},s={},c=[{value:"Targets and Dependencies",id:"targets-and-dependencies",level:2},{value:"Complex Dependencies",id:"complex-dependencies",level:3},{value:"Fake Targets",id:"fake-targets",level:3},{value:"Examples",id:"examples",level:2}],m={toc:c};function u(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"make-and-makefiles"},"Make and Makefiles"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"make")," is a specialized scripting language used to build software. Unlike most scripting languages, commands are not executed in linear (start-to-finish) sequence; instead, command sequences are defined in terms of what input they accept and what output they produce, and ",(0,l.kt)("em",{parentName:"p"},"make")," automatically sequences the commands to produce the required output."),(0,l.kt)("p",null,"Running the ",(0,l.kt)("inlineCode",{parentName:"p"},"make")," command by itself will execute the makefile script named ",(0,l.kt)("inlineCode",{parentName:"p"},"Makefile")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"makefile")," in the current directory."),(0,l.kt)("h2",{id:"targets-and-dependencies"},"Targets and Dependencies"),(0,l.kt)("p",null,"Picture a very simple build, where the file ",(0,l.kt)("inlineCode",{parentName:"p"},"test.c")," is compiled by gcc into the executable binary named ",(0,l.kt)("inlineCode",{parentName:"p"},"test"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"test.c -> compiled by the command 'gcc test.c  -o test' -> test\n")),(0,l.kt)("p",null,"The binary executable product file, ",(0,l.kt)("inlineCode",{parentName:"p"},"test"),", is considered the ",(0,l.kt)("em",{parentName:"p"},"target")," -- the object to be built. The file ",(0,l.kt)("inlineCode",{parentName:"p"},"test.c")," is a dependency - a file that is required in order to produce the target. ",(0,l.kt)("em",{parentName:"p"},"gcc")," is the command that builds the target from the dependency."),(0,l.kt)("p",null,"In a make script (typically called a ",(0,l.kt)("em",{parentName:"p"},"Makefile"),"), the syntax looks like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"target: dependencies\n        commands\n")),(0,l.kt)("p",null,"(Note that the ",(0,l.kt)("em",{parentName:"p"},"commands")," must be indented by tabs and not spaces in most versions of ",(0,l.kt)("em",{parentName:"p"},"make"),")."),(0,l.kt)("p",null,"The example above could be written:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"test: test.c\n      gcc test.c -o test\n")),(0,l.kt)("p",null,"Here is the result when this ",(0,l.kt)("em",{parentName:"p"},"Makefile")," is executed:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"$ ls -l\ntotal 8\n-rw-rw-r--. 1 chris chris 35 Jan 10 19:21 Makefile\n-rw-rw-r--. 1 chris chris 40 Jan 10 19:15 test.c\n$ cat Makefile\ntest:     test.c\n          gcc -o test test.c\n\n$ make\ngcc -o test test.c\n")),(0,l.kt)("p",null,"When executed a second time, make does nothing:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"$ make\nmake: `test' is up to date.\n")),(0,l.kt)("p",null,"This is because the timestamp on the target (",(0,l.kt)("inlineCode",{parentName:"p"},"test"),") is later than the timestamp on the dependency (",(0,l.kt)("inlineCode",{parentName:"p"},"test.c"),"). If the dependency has been changed since the target was built, though, then ",(0,l.kt)("em",{parentName:"p"},"make")," will rebuild the target."),(0,l.kt)("h3",{id:"complex-dependencies"},"Complex Dependencies"),(0,l.kt)("p",null,"A more complicated build will involve a number of targets and dependencies. C programs, for example, can be compiled into intermediate files, called object files (.o extension), which can then be combined to produce executables."),(0,l.kt)("p",null,"Picture this scenario:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"There are three object files:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"double.c, number.h, and sauce.h compile to make: double.o"),(0,l.kt)("li",{parentName:"ul"},"half.c, number.h, and sauce.h compile to make: half.o"),(0,l.kt)("li",{parentName:"ul"},"sauce.c compiles to make: sauce.o"))),(0,l.kt)("li",{parentName:"ul"},"There are two binary targets:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"double.o and sauce.o can be linked to produce: double"),(0,l.kt)("li",{parentName:"ul"},"half.o and sauce.o can be linked to produce: half")))),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"Makefile")," for these relationships may be written like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"CC=cc\nCFLAGS=-O3\n\nall:         half double\n\nhalf:        half.o sauce.o\n             ${CC} ${CFLAGS} -o half half.o sauce.o\n\ndouble:      double.o sauce.o\n             ${CC} ${CFLAGS} -o double double.o sauce.o\n\nhalf.o:      half.c number.h\n             ${CC} ${CFLAGS} -c half.c\n\ndouble.o:    double.c number.h\n             ${CC} ${CFLAGS} -c double.c\n       \nsauce.o:     sauce.c\n             ${CC} ${CFLAGS} -c sauce.c\n\n")),(0,l.kt)("p",null,"There are several things worth noting about this ",(0,l.kt)("em",{parentName:"p"},"Makefile"),":"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Variables are used for the name of the compiler and the compiler flags. This makes it very easy to change these values -- to use the ",(0,l.kt)("em",{parentName:"li"},"gcc")," compiler, for example, the CC variable could simply be changed to ",(0,l.kt)("em",{parentName:"li"},"gcc"),". If variables were not used, you would have to change every line that invoked the compiler."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("em",{parentName:"li"},"all")," is a dummy target. Since it appears as the first target in the file, it is executed by default if no target is specified as an argument to the ",(0,l.kt)("inlineCode",{parentName:"li"},"make")," command. It depends on the ",(0,l.kt)("em",{parentName:"li"},"half")," and ",(0,l.kt)("em",{parentName:"li"},"double")," files, which will be built in order to satisfy the dependency. However, the all target does not specify any commands, and the file ",(0,l.kt)("inlineCode",{parentName:"li"},"all")," will never be built.")),(0,l.kt)("p",null,"When ",(0,l.kt)("em",{parentName:"p"},"make")," is executed the first time, five compilations are performed:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"$ make\ncc         -O3 -c half.c\ncc         -O3 -c sauce.c\ncc         -O3 -o half half.o sauce.o\ncc         -O3 -c double.c\ncc         -O3 -o double double.o sauce.o\n")),(0,l.kt)("p",null,"Note that the commands are not being executed in the order in which they appear in the file -- instead, they are ordered according to dependencies."),(0,l.kt)("p",null,"When executed a second time, no compilations are performed:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"$ make\nmake: Nothing to be done for 'all'.\n")),(0,l.kt)("p",null,"If the file ",(0,l.kt)("inlineCode",{parentName:"p"},"half.c")," was edited or the last-modified timestamp (mtime) was updated, running ",(0,l.kt)("em",{parentName:"p"},"make")," would execute two compilations:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"$ touch half.c\n$ make\ncc         -O3 -c half.c\ncc         -O3 -o half half.o sauce.o\n")),(0,l.kt)("p",null,"This reveals the power of ",(0,l.kt)("em",{parentName:"p"},"make")," -- it does the absolute minimum in order to build the specified target."),(0,l.kt)("p",null,"On a large programming project, a binary may be comprised of hundreds or even thousands of source files, and compiling all of those files may take hours. If a software developer edits just one file, it's a waste of time to rebuild everything, so ",(0,l.kt)("em",{parentName:"p"},"make")," can save a lot of time -- especially when the software is rebuilt many thousand times."),(0,l.kt)("h3",{id:"fake-targets"},"Fake Targets"),(0,l.kt)("p",null,'It is not uncommon to include "fake" targets in a Makefile -- targets which never get built, but which perform a useful operation. For example, a target of "all" never produces an actual file named "all". Typical fake targets include:'),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"all: build all binaries"),(0,l.kt)("li",{parentName:"ul"},"docs: builts all documentation (e.g., generates PDFs, HTML, manpages, etc)"),(0,l.kt)("li",{parentName:"ul"},"install: install all files, building binaries, documentation, etc if required"),(0,l.kt)("li",{parentName:"ul"},"clean: erases all built intermediate and binary files"),(0,l.kt)("li",{parentName:"ul"},"dist-clean (or distclean): erases all files not included in the original distribution of the source"),(0,l.kt)("li",{parentName:"ul"},"check (or test): tests the software")),(0,l.kt)("p",null,'The make command will exit as soon as any command pipeline fails, so fake targets which may non-fatally fail are usually forced to return a success code; for example, to delete files which may or may not exist as part of a "clean" target, code such as this may be used:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"rm *.o || true\n")),(0,l.kt)("h2",{id:"examples"},"Examples"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"http://matrix.senecacollege.ca/~chris.tyler/osd600/makefile-examples.tgz"},"A tarball of simple Makefile examples"))))}u.isMDXComponent=!0}}]);