"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[5161],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return m}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var o=n.createContext({}),u=function(e){var t=n.useContext(o),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(r),m=a,g=d["".concat(o,".").concat(m)]||d[m]||p[m]||i;return r?n.createElement(g,s(s({ref:t},c),{},{components:r})):n.createElement(g,s({ref:t},c))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,s=new Array(i);s[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var u=2;u<i;u++)s[u]=r[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},7068:function(e,t,r){r.r(t),r.d(t,{assets:function(){return o},contentTitle:function(){return s},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var n=r(3117),a=(r(7294),r(3905));const i={id:"x86-64-register-and-instruction-quick-start",title:"X86 64 Register and Instruction Quick Start",sidebar_position:8,description:"X86 64 Register and Instruction Quick Start"},s="X86 64 Register and Instruction Quick Start",l={unversionedId:"F-AssemblyLanguage/x86-64-register-and-instruction-quick-start",id:"F-AssemblyLanguage/x86-64-register-and-instruction-quick-start",title:"X86 64 Register and Instruction Quick Start",description:"X86 64 Register and Instruction Quick Start",source:"@site/docs/F-AssemblyLanguage/x86-64-register-and-instruction-quick-start.md",sourceDirName:"F-AssemblyLanguage",slug:"/F-AssemblyLanguage/x86-64-register-and-instruction-quick-start",permalink:"/SPO600/F-AssemblyLanguage/x86-64-register-and-instruction-quick-start",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/F-AssemblyLanguage/x86-64-register-and-instruction-quick-start.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{id:"x86-64-register-and-instruction-quick-start",title:"X86 64 Register and Instruction Quick Start",sidebar_position:8,description:"X86 64 Register and Instruction Quick Start"},sidebar:"courseNotesSidebar",previous:{title:"AArch64 Register and Instruction Quick Start",permalink:"/SPO600/F-AssemblyLanguage/aarch64-register-and-instruction-quick-start"},next:{title:"ARMv8",permalink:"/SPO600/H-ARM/armv8"}},o={},u=[{value:"Registers",id:"registers",level:2},{value:"General-Purpose Registers",id:"general-purpose-registers",level:3},{value:"Floating-Point and SIMD Registers",id:"floating-point-and-simd-registers",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Starter Kit",id:"starter-kit",level:3},{value:"Resources",id:"resources",level:2}],c={toc:u};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"x86-64-register-and-instruction-quick-start"},"X86 64 Register and Instruction Quick Start"),(0,a.kt)("p",null,"This page contains very basic information on the x86_64 architecture: the ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/E-ComputerArchitecture/register"},"register")," layout and naming and the some basic instructions."),(0,a.kt)("h2",{id:"registers"},"Registers"),(0,a.kt)("h3",{id:"general-purpose-registers"},"General-Purpose Registers"),(0,a.kt)("p",null,"The 64-bit versions of the 'original' x86 registers are named:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"rax - register a extended"),(0,a.kt)("li",{parentName:"ul"},"rbx - register b extended"),(0,a.kt)("li",{parentName:"ul"},"rcx - register c extended"),(0,a.kt)("li",{parentName:"ul"},"rdx - register d extended"),(0,a.kt)("li",{parentName:"ul"},"rbp - register base pointer (start of stack)"),(0,a.kt)("li",{parentName:"ul"},"rsp - register stack pointer (current location in stack, growing downwards)"),(0,a.kt)("li",{parentName:"ul"},"rsi - register source index (source for data copies)"),(0,a.kt)("li",{parentName:"ul"},"rdi - register destination index (destination for data copies)")),(0,a.kt)("p",null,"The registers added for 64-bit mode are named:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"r8 - register 8"),(0,a.kt)("li",{parentName:"ul"},"r9 - register 9"),(0,a.kt)("li",{parentName:"ul"},"r10 - register 10"),(0,a.kt)("li",{parentName:"ul"},"r11 - register 11"),(0,a.kt)("li",{parentName:"ul"},"r12 - register 12"),(0,a.kt)("li",{parentName:"ul"},"r13 - register 13"),(0,a.kt)("li",{parentName:"ul"},"r14 - register 14"),(0,a.kt)("li",{parentName:"ul"},"r15 - register 15")),(0,a.kt)("p",null,"These may be accessed as:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"64-bit registers using the 'r' prefix: rax, r15"),(0,a.kt)("li",{parentName:"ul"},"32-bit registers using the 'e' prefix (original registers: e_x) or 'd' suffix (added registers: r__d): eax, r15d"),(0,a.kt)("li",{parentName:"ul"},"16-bit registers using no prefix (original registers: _x) or a 'w' suffix (added registers: r__w): ax, r15w"),(0,a.kt)("li",{parentName:"ul"},"8-bit registers using 'h' (\"high byte\" of 16 bits) suffix (original registers - bits 8-15: _h): ah, bh"),(0,a.kt)("li",{parentName:"ul"},"8-bit registers using 'l' (\"low byte\" of 16 bits) suffix (original registers - bits 0-7: _l) or 'b' suffix (added registers: r__b): al, bl, r15b")),(0,a.kt)("p",null,"Usage during ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/F-AssemblyLanguage/syscalls"},"syscall"),"/function call:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"First six arguments are in rdi, rsi, rdx, rcx, r8d, r9d; remaining arguments are on the stack."),(0,a.kt)("li",{parentName:"ul"},"For syscalls, the syscall number is in rax. For procedure calls, rax should be set to 0."),(0,a.kt)("li",{parentName:"ul"},"Return value is in rax."),(0,a.kt)("li",{parentName:"ul"},"The called routine is expected to preserve rsp,rbp, rbx, r12, r13, r14, and r15 but may trample any other registers.")),(0,a.kt)("h3",{id:"floating-point-and-simd-registers"},"Floating-Point and SIMD Registers"),(0,a.kt)("p",null,"x86_64 also defines a set of large registers for floating-point and single-instruction/multiple-data (SIMD) operations. For details, refer to the Intel or AMD documentation."),(0,a.kt)("h2",{id:"instructions"},"Instructions"),(0,a.kt)("h3",{id:"starter-kit"},"Starter Kit"),(0,a.kt)("p",null,"These instructions are sufficient to complete the ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/B-Labs/lab4"},"SPO600 Assembler Lab")," (GAS syntax):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},'add %r10,%r11    // add r10 and r11, put result in r11\nadd $5,%r10      // add 5 to r10, put result in r10\ncall label       // call a subroutine / function / procedure\ncmp %r10,%r11    // compare register r10 with register r11.  The comparison sets flags in the processor status register which affect conditional jumps.\ncmp $99,%r11     // compare the number 99 with register r11.  The comparison sets flags in the processor status register which affect conditional jumps.\ndiv %r10         // divide rax by the given register (r10), places quotient into rax and remainder into rdx (rdx must be zero before this instruction)\ninc %r10         // increment r10\njmp label        // jump to label\nje  label        // jump to label if equal\njne label        // jump to label if not equal\njl  label        // jump to label if less\njg  label        // jump to label if greater\nmov %r10,%r11    // move data from r10 to r11\nmov $99,%r10     // put the immediate value 99 into r10\nmov %r10,(%r11)  // move data from r10 to address pointed to by r11\nmov (%r10),%r11  // move data from address pointed to by r10 to r10\nmul %r10         // multiplies rax by r10, places result in rax and overflow in rdx\npush %r10        // push r10 onto the stack\npop %r10         // pop r10 off the stack\nret              // routine from subroutine (counterpart to call)\nsyscall          // invoke a syscall (in 32-bit mode, use "int $0x80" instead)\n')),(0,a.kt)("p",null,"Note the syntax:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/SPO600/E-ComputerArchitecture/register"},"Register")," names are prefixed by %"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/SPO600/E-ComputerArchitecture/immediate-value"},"Immediate values")," are prefixed by $"),(0,a.kt)("li",{parentName:"ul"},"Indirect memory access is indicated by (parenthesis)."),(0,a.kt)("li",{parentName:"ul"},"Hexadecimal values are indicated by a 0x prefix."),(0,a.kt)("li",{parentName:"ul"},"Character values are indicated by quotation marks. Escapes (such as '\\n') are permitted."),(0,a.kt)("li",{parentName:"ul"},"Data sources are given as the first argument (mov %r10,%r11 moves FROM r10 INTO r11).")),(0,a.kt)("p",null,"For the MOV instruction:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"You can append a suffix indicating the amount of data to be moved -- e.g., q for quadword (64 bits), d for doubleword (32 bits), w for word (16 bits), or b for byte (8 bits).")),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"CPU Instruction Set and Software Developer Manuals",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"AMD: ",(0,a.kt)("a",{parentName:"li",href:"https://developer.amd.com/resources/developer-guides-manuals/"},"https://developer.amd.com/resources/developer-guides-manuals/")," (see the AMD64 Architecture section, particularly the ",(0,a.kt)("em",{parentName:"li"},"AMD64 Architecture Programmer\u2019s Manual")," Volume 3: General Purpose and System Instructions)"),(0,a.kt)("li",{parentName:"ul"},"Intel: ",(0,a.kt)("a",{parentName:"li",href:"http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html"},"http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html")))),(0,a.kt)("li",{parentName:"ul"},"Web sites",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"http://ref.x86asm.net/"},"http://ref.x86asm.net/")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"http://sandpile.org/"},"http://sandpile.org/")))),(0,a.kt)("li",{parentName:"ul"},"GAS Manual - Using as, The GNU Assembler: ",(0,a.kt)("a",{parentName:"li",href:"https://sourceware.org/binutils/docs/as/"},"https://sourceware.org/binutils/docs/as/"))))}p.isMDXComponent=!0}}]);