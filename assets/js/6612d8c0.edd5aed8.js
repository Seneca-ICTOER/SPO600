"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[4912],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,g=m["".concat(o,".").concat(d)]||m[d]||c[d]||i;return n?a.createElement(g,s(s({ref:t},p),{},{components:n})):a.createElement(g,s({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var u=2;u<i;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4002:function(e,t,n){n.r(t),n.d(t,{assets:function(){return o},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var a=n(3117),r=(n(7294),n(3905));const i={id:"inline-assembly-language",title:"Inline Assembly Language",sidebar_position:3,description:"Inline Assembly Language"},s="Inline Assembly Language",l={unversionedId:"F-AssemblyLanguage/inline-assembly-language",id:"F-AssemblyLanguage/inline-assembly-language",title:"Inline Assembly Language",description:"Inline Assembly Language",source:"@site/docs/F-AssemblyLanguage/inline-assembly-language.md",sourceDirName:"F-AssemblyLanguage",slug:"/F-AssemblyLanguage/inline-assembly-language",permalink:"/SPO600/F-AssemblyLanguage/inline-assembly-language",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/F-AssemblyLanguage/inline-assembly-language.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"inline-assembly-language",title:"Inline Assembly Language",sidebar_position:3,description:"Inline Assembly Language"},sidebar:"courseNotesSidebar",previous:{title:"Assembler Basics",permalink:"/SPO600/F-AssemblyLanguage/assembler-basics"},next:{title:"Executable and Linkable Format",permalink:"/SPO600/F-AssemblyLanguage/executable-and-linkable-format"}},o={},u=[{value:"Syntax",id:"syntax",level:2},{value:"Assembler Template",id:"assembler-template",level:3},{value:"Output and Input Operands",id:"output-and-input-operands",level:3},{value:"Using a Specific Register Width on AArch64",id:"using-a-specific-register-width-on-aarch64",level:3},{value:"Constraining an Operand to a Specific Register",id:"constraining-an-operand-to-a-specific-register",level:3},{value:"Register Constraints using Explicit Register Variables",id:"register-constraints-using-explicit-register-variables",level:3},{value:"i386 Register Names",id:"i386-register-names",level:3},{value:"Clobber",id:"clobber",level:3},{value:"Resources",id:"resources",level:2}],p={toc:u};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"inline-assembly-language"},"Inline Assembly Language"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Inline Assembly")," is ",(0,r.kt)("a",{parentName:"p",href:"/SPO600/F-AssemblyLanguage/assembly-language"},"assembly language")," code which is embedded in a program written in another language, typically C."),(0,r.kt)("p",null,"In open source software (especially in a Linux context), this is most commonly done using gcc, but inline assembler is also supported by llvm/clang, the Intel C compilers, Microsoft Visual Studio, and various other tools. Here we're going to focus on gcc."),(0,r.kt)("h2",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"Inline assembler is included in a GCC C source file in one of these two forms:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"asm(...);\n__asm__ (...);                  // Those are double underscores!\n")),(0,r.kt)("p",null,"If it is critical that the code not be moved by the compiler (for example, as the result of an optimization), include the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"volatile"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"asm volatile (...);\n__asm__ __volatile__ (...);     // Double underscores all over the place\n")),(0,r.kt)("p",null,"Inside the parenthesis, there are up to four sections separated by colons. There are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The assembler template (mandatory)"),(0,r.kt)("li",{parentName:"ol"},"Output operands (optional)"),(0,r.kt)("li",{parentName:"ol"},"Input operands (optional)"),(0,r.kt)("li",{parentName:"ol"},"Clobbers (optional)")),(0,r.kt)("h3",{id:"assembler-template"},"Assembler Template"),(0,r.kt)("p",null,"The assembler template is a piece of assembler code that will be pre-processed to fill in register assignments. Registers may be referenced as %0, %1, %2 and so forth, indicating the registers mentioned in the output operands and input operands. For example, if there is one output operand and two input operands, you can refer to the register containing the output operand as ",(0,r.kt)("inlineCode",{parentName:"p"},"%0")," and the input operands as ",(0,r.kt)("inlineCode",{parentName:"p"},"%1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"%2"),"."),(0,r.kt)("p",null,"Because % is used as a prefix for register numbers (using some assembly language dialects), a double percent-sign must be used to represent a single percent sign in the code. For example, in x86_64 gas assembler, the rax register is written as ",(0,r.kt)("inlineCode",{parentName:"p"},"%rax")," -- but in a template, it must be written as ",(0,r.kt)("inlineCode",{parentName:"p"},"%%rax"),"."),(0,r.kt)("p",null,"The template is written as one or more strings enclosed in quotes, with no separator other than whitespace between the strings. Individual statements in the asm code must be separated by semi-colons (;) or explicit newline characters (\\n). The sequence \\t can be used to indicate a tab character."),(0,r.kt)("p",null,"These are all valid:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'asm("mov %1,%0;inc %0");\n\n__asm__ ("mov %1,%0\\ninc %0");\n\n__asm__ ("mov %1,%0\\n" "inc %0");\n\n__asm__ ("mov %1,%0\\n\\t"\n         "inc $0");\n')),(0,r.kt)("p",null,"These are not valid:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'asm("mov %1,%0\n     inc %0");   // the assembler will not see a delimiter between the statements\n\n__asm__ ("mov %1,%0\\n","inc %0");  // do not place a comma between the strings\n')),(0,r.kt)("h3",{id:"output-and-input-operands"},"Output and Input Operands"),(0,r.kt)("p",null,"Output and input operands are optional -- some asm code may do a task without any input or output values."),(0,r.kt)("p",null,"If the asm code has input or output values, these operands are specified as an optional name in square brackets, a quoted string containing a constraint, and a C expression in parenthesis."),(0,r.kt)("p",null,"Constraints are specified as a string of characters. Some commonly use constraints are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"r - any general-purpose register is permitted."),(0,r.kt)("li",{parentName:"ul"},'0-9 - the same register used in the matching number operand should be used (for example, "1" indicates that the same register should be used as operand 1).'),(0,r.kt)("li",{parentName:"ul"},"i - an immediate integer value is permitted."),(0,r.kt)("li",{parentName:"ul"},"F - an immediate floating-point value is permitted.")),(0,r.kt)("p",null,"There are additional generic and platform-specific constraints (for example, for SIMD and floating-point registers). Refer to the gcc documentation for details (see ",(0,r.kt)("a",{parentName:"p",href:"#resources"},"resources"),")."),(0,r.kt)("p",null,"These constraints are combined with a modifier, required for output operands:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"= - output-only register - previous contents are discarded and replaced with output value (this does not preclude use as in input register)"),(0,r.kt)("li",{parentName:"ul"},"+"," ","-"," input and output register - this register will be used to both pass input data to the asm code, and to receive a value from the asm code"),(0,r.kt)("li",{parentName:"ul"},"& - earlyclobber register - this value may be overwritten before input is processed, therefore it must not be used for input"),(0,r.kt)("li",{parentName:"ul"},"% - in addition to one of the symbols above, declares that this operand and the following operand are commutable (interchangeable) for optimization. Only one commutable pair may be specified.")),(0,r.kt)("p",null,"The constraint is followed by a C expression in parenthesis to provide the value (input operand) or receive the value (output operand). This is usually a variable name for output operands, but may be a variable name, evaluated expression, or a constant for input operands."),(0,r.kt)("p",null,"Here are some (trivial) examples in x86_64 assembler:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'int x=10, y;\n__asm__ ("mov %1,%0"\n\n   : "=r"(y)    // output register value is moved to y\n                // register is called %0 in template\n\n   : "r"(x)     // input value from x is placed in a register\n                // register is called %1 in template\n   :\n);\n')),(0,r.kt)("p",null,"In the example above, one or two registers are used for input and output -- the compiler can choose whether to use the same register for input and output, or to use separate ones. We can specify that only one register is to be used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'int x=10, y;\n__asm__ ("mov %1,%0"\n   : "+r"(y)       // + indicates read/write register\n   : "0"(x)        // output register is same as %0\n   :\n);\n')),(0,r.kt)("p",null,"The registers may be referenced by name instead of number if a name is provided in the operand sections:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'int x=10, y;\n__asm__ ("mov %[in],%[out]"\n   : [out]"=r"(y)  // register may be called %[out]\n   : [in]"r"(x)    // register may be called %[in]\n   :\n);\n')),(0,r.kt)("h3",{id:"using-a-specific-register-width-on-aarch64"},"Using a Specific Register Width on AArch64"),(0,r.kt)("p",null,"On AArch64, you may need to access a 32-bit version of a register. To do this with templated register names, you can add the 'w' modifier. For example, if %0 is x22 and you need to access w22, use %w0."),(0,r.kt)("h3",{id:"constraining-an-operand-to-a-specific-register"},"Constraining an Operand to a Specific Register"),(0,r.kt)("p",null,"It is sometimes useful to constrain an operand to a particular register to avoid having to perform moves within the asm code (for example, if an operand will be used as the input to a function call or ",(0,r.kt)("a",{parentName:"p",href:"/SPO600/F-AssemblyLanguage/syscalls"},"syscall"),")."),(0,r.kt)("h3",{id:"register-constraints-using-explicit-register-variables"},"Register Constraints using Explicit Register Variables"),(0,r.kt)("p",null,"To select a specific register for a operand, use a (perhaps temporary) variable in operand's C expression that is locked to a particular register in that variable's C declaration, using ",(0,r.kt)("a",{parentName:"p",href:"http://gcc.gnu.org/onlinedocs/gcc-4.8.2/gcc/Local-Reg-Vars.html#Local-Reg-Vars"},"explicit register variables"),"."),(0,r.kt)("p",null,"For example, in aarch64 asm:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'int x=10;\nregister int y asm("r15");\n\nasm("mov %1,%0; inc r15;"\n   : "=r"(y)\n   : "r"(x)   // register r15\n   :\n);\n')),(0,r.kt)("p",null,'In this example, the variable y is constrained in C to the r15 register. The "inc r15" in the assembler template therefore increments the output register after the mov instructions.'),(0,r.kt)("h3",{id:"i386-register-names"},"i386 Register Names"),(0,r.kt)("p",null,"On i386 only, specific registers may be selected by using ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"d")," in place of ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," as a register constraint. Using ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", for example, will select the rax/eax register."),(0,r.kt)("h3",{id:"clobber"},"Clobber"),(0,r.kt)("p",null,"If your code will clobber (overwrite) registers or memory regions, these must be listed after the third colon within the asm parenthesis. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'asm("..."\n    : "=r"(out)\n    :  "r"(in)\n    : "rax", "rbx", "rsi"   // values in rax, rbx, rsi will be clobbered\n);\n')),(0,r.kt)("p",null,'If memory is altered by the asm code, the string "memory" should be added to the clobber list. This will cause the compiler to mistrust values that were loaded from memory before the assembly language code was executed -- for example, if register r12 is loaded with an integer from memory before the assembly code is executed, it will be reloaded from memory afterward, because the value in memory may have been modified by the assembly code. If a memory clobber is not specified, the compiler will assume that values previously loaded from memory still match the values in memory. In most cases, the ',(0,r.kt)("inlineCode",{parentName:"p"},"volatile")," keyword should be used along with the memory clobber flag."),(0,r.kt)("p",null,'If the condition code (status register or flag register) (ADD LINK) is altered, the string "cc" should be added to the clobber list.'),(0,r.kt)("h2",{id:"resources"},"Resources"),(0,r.kt)("p",null,"There are many other options applicable to special situations or specific architectures. All of these are documented here:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://gcc.gnu.org/onlinedocs/gcc-4.8.2/gcc/Extended-Asm.html"},"GNU Assembler Manual"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Specifically, see the ",(0,r.kt)("a",{parentName:"li",href:"http://gcc.gnu.org/onlinedocs/gcc-4.8.2/gcc/Extended-Asm.html"},"Assembler Instructions with C Expression Operands")," section")))))}c.isMDXComponent=!0}}]);