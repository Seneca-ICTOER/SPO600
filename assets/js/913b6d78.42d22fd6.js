"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[8759],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return d}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=l(r),d=o,h=m["".concat(c,".").concat(d)]||m[d]||p[d]||i;return r?n.createElement(h,a(a({ref:t},u),{},{components:r})):n.createElement(h,a({ref:t},u))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},997:function(e,t,r){r.r(t),r.d(t,{assets:function(){return c},contentTitle:function(){return a},default:function(){return p},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l}});var n=r(3117),o=(r(7294),r(3905));const i={id:"sve2",title:"SVE2",sidebar_position:2,description:"SVE2"},a="SVE2",s={unversionedId:"H-ARM/sve2",id:"H-ARM/sve2",title:"SVE2",description:"SVE2",source:"@site/docs/H-ARM/sve2.md",sourceDirName:"H-ARM",slug:"/H-ARM/sve2",permalink:"/SPO600/H-ARM/sve2",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/H-ARM/sve2.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"sve2",title:"SVE2",sidebar_position:2,description:"SVE2"},sidebar:"courseNotesSidebar",previous:{title:"ARMv8",permalink:"/SPO600/H-ARM/armv8"},next:{title:"6502",permalink:"/SPO600/G-6502/6502"}},c={},l=[{value:"Resources",id:"resources",level:2},{value:"Building SVE2 Code",id:"building-sve2-code",level:2},{value:"C Compiler Options",id:"c-compiler-options",level:3},{value:"Using SVE2 Intrinsics Header Files",id:"using-sve2-intrinsics-header-files",level:3},{value:"Macro for SVE2",id:"macro-for-sve2",level:3},{value:"Running SVE2 Code",id:"running-sve2-code",level:2}],u={toc:l};function p(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"sve2"},"SVE2"),(0,o.kt)("p",null,"The Armv9 ",(0,o.kt)("strong",{parentName:"p"},"Scalable Vector Extensions verision 2")," (SVE2) provide a variable-witdh SIMD capability for ",(0,o.kt)("a",{parentName:"p",href:"/SPO600/H-ARM/armv8"},"AArch64")," systems. Note that SVE2 is a minor refinement and standardization of the original Scalable Vector Extensions (used on the ",(0,o.kt)("a",{parentName:"p",href:"https://www.r-ccs.riken.jp/en/fugaku/"},"Fugaku")," supercomputer), so most materials discussing SVE are also applicable to SVE2 (which will be used on systems ranging from smartphones to servers to supercomputers)."),(0,o.kt)("h2",{id:"resources"},"Resources"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Arm Armv9-A A64 Instruction Set Architecture - ",(0,o.kt)("a",{parentName:"li",href:"https://developer.arm.com/documentation/ddi0602/2021-12/"},"https://developer.arm.com/documentation/ddi0602/2021-12/")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Introduction to SVE2")," - ",(0,o.kt)("a",{parentName:"li",href:"https://developer.arm.com/documentation/102340/0001/?lang=en"},"https://developer.arm.com/documentation/102340/0001/?lang=en")),(0,o.kt)("li",{parentName:"ul"},"Intrinsics - Arm C Language Extensions for SVE (ACLE) - ",(0,o.kt)("a",{parentName:"li",href:"https://developer.arm.com/documentation/100987/latest"},"https://developer.arm.com/documentation/100987/latest")),(0,o.kt)("li",{parentName:"ul"},"SVE Coding Considerations with Arm Compiler - Note that this documentation is specific to Arm's own compiler, but most of it will be applicable to other compilers including gcc - ",(0,o.kt)("a",{parentName:"li",href:"https://developer.arm.com/documentation/100748/0616/SVE-Coding-Considerations-with-Arm-Compiler"},"https://developer.arm.com/documentation/100748/0616/SVE-Coding-Considerations-with-Arm-Compiler"))),(0,o.kt)("h2",{id:"building-sve2-code"},"Building SVE2 Code"),(0,o.kt)("h3",{id:"c-compiler-options"},"C Compiler Options"),(0,o.kt)("p",null,"At the time of writing (March 2022), most compilers do not have a specific target for Armv9 systems. Therefore, to build code that includes SVE2 instructions, you will need to instruct the complier to emit code for an Armv8-a processor that also understands the SVE2 instructions; on the GCC compiler, this is performed using the ",(0,o.kt)("inlineCode",{parentName:"p"},"-march="),' option (which is read as "machine architecture"). ',(0,o.kt)("strong",{parentName:"p"},"You must do this regardless of whether you're using autovectorization, inline assembler, or intrinsics"),'. The architecture specificaion for this target is currently "armv8-a+sve2":'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"gcc -march=armv8-a+sve2 ...\n")),(0,o.kt)("p",null,"Remember that in order to invoke the autovectorizer in GCC version 11, you must use ",(0,o.kt)("inlineCode",{parentName:"p"},"-O3")," or the appropriate feature options (",(0,o.kt)("inlineCode",{parentName:"p"},"-ftree-vectorize"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"gcc -O3 -march=armv8-a+sve2 ...\n\ngcc -O2 -march=armv8-a+sve2 -ftree-vectorize ...\n")),(0,o.kt)("h3",{id:"using-sve2-intrinsics-header-files"},"Using SVE2 Intrinsics Header Files"),(0,o.kt)("p",null,"To use SVE2 intrinsics in a C program, include the header file ",(0,o.kt)("inlineCode",{parentName:"p"},"arm_sve.h"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"#include <arm_sve.h>\n")),(0,o.kt)("p",null,"Note: some ARM documentation will refer to ",(0,o.kt)("inlineCode",{parentName:"p"},"<arm_sve2.h>"),", but in gcc, the correct file is ",(0,o.kt)("inlineCode",{parentName:"p"},"<arm_sve.h>")),(0,o.kt)("h3",{id:"macro-for-sve2"},"Macro for SVE2"),(0,o.kt)("p",null,"To detect SVE2 capability in the compilation target, use the macro ",(0,o.kt)("inlineCode",{parentName:"p"},"__ARM_FEATURE_SVE2"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"#if __ARM_FEATURE_SVE2\n...\n#endif\n")),(0,o.kt)("h2",{id:"running-sve2-code"},"Running SVE2 Code"),(0,o.kt)("p",null,"To run SVE2 code on an Armv8 computer, you can use the QEMU usermode software. This will trap SVE2 instructions and emulate them in software, while executing Armv8a instructions directly on the hardware:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"qemu-aarch64 ./binary\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Running AArch64 code on x86_64:")," The QEMU user mode software can also be used to run AArch64 code on an x86_64 system (albeit slowly). However, this requires a full AArch64 userspace (applications and tools, such as ld) to be installed on the x86_64 system."))}p.isMDXComponent=!0}}]);