"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[7105],{3905:function(e,t,r){r.d(t,{Zo:function(){return l},kt:function(){return d}});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},l=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),f=u(r),d=i,m=f["".concat(s,".").concat(d)]||f[d]||p[d]||a;return r?n.createElement(m,o(o({ref:t},l),{},{components:r})):n.createElement(m,o({ref:t},l))}));function d(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=f;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,o[1]=c;for(var u=2;u<a;u++)o[u]=r[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},9802:function(e,t,r){r.r(t),r.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return a},metadata:function(){return c},toc:function(){return u}});var n=r(3117),i=(r(7294),r(3905));const a={id:"ieee-754",title:"IEEE 754",sidebar_position:16,description:"IEEE 754"},o="IEEE 754",c={unversionedId:"E-ComputerArchitecture/ieee-754",id:"E-ComputerArchitecture/ieee-754",title:"IEEE 754",description:"IEEE 754",source:"@site/docs/E-ComputerArchitecture/ieee-754.md",sourceDirName:"E-ComputerArchitecture",slug:"/E-ComputerArchitecture/ieee-754",permalink:"/SPO600/E-ComputerArchitecture/ieee-754",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/E-ComputerArchitecture/ieee-754.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{id:"ieee-754",title:"IEEE 754",sidebar_position:16,description:"IEEE 754"},sidebar:"courseNotesSidebar",previous:{title:"Flags",permalink:"/SPO600/E-ComputerArchitecture/flags"},next:{title:"Immediate Value",permalink:"/SPO600/E-ComputerArchitecture/immediate-value"}},s={},u=[{value:"References",id:"references",level:2}],l={toc:u};function p(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"ieee-754"},"IEEE 754"),(0,i.kt)("p",null,"The Institute of Electrical and Electronics Engineers (IEEE) standard 754 defines a format for floating-point numbers used in most modern computers. ISO 60559 is an international version of the same standard (though it may lag behind the IEEE version's updates)."),(0,i.kt)("p",null,"IEEE 754 defines a single-precision floating point format with 32 bits (24 significand bits (one of which is implied), 8 exponent bits, and one sign bit), including special values (such as infinity and not-a-number (NaN)). It then defines half-, double-, quadruple-, and octuple-precision versions, with 16, 64, 128, and 256 bits, respectively."),(0,i.kt)("p",null,'In IEEE 754, both the number of significand and exponent bits vary with the format. Therefore, naming the various lengths as different "precisions" is not completely accurate, because they can also express varying ranges of values. For this reason, other formats such as bfloat16, a 16-bit floating point format with the same dynamic range as IEEE 754 single-precision but with fewer significand bits, have become popular for particular applications such as machine learning.'),(0,i.kt)("p",null,"The IEEE 754 standard also defines interchange formats, rounding rules, and exceptions, as well as rarely-used decimal floating-point formats."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/IEEE_754"},"Wikipedia article on IEEE 754")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.h-schmidt.net/FloatConverter/IEEE754.html"},"IEEE 754 Calculator"))))}p.isMDXComponent=!0}}]);