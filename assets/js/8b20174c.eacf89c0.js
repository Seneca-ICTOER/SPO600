"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[7584],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return m}});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},s=Object.keys(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var d=r.createContext({}),l=function(e){var t=r.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=l(e.components);return r.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,d=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=l(a),m=n,h=p["".concat(d,".").concat(m)]||p[m]||c[m]||s;return a?r.createElement(h,i(i({ref:t},u),{},{components:a})):r.createElement(h,i({ref:t},u))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,i=new Array(s);i[0]=p;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var l=2;l<s;l++)i[l]=a[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},6563:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return i},default:function(){return c},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return l}});var r=a(3117),n=(a(7294),a(3905));const s={id:"6502-addressing-modes",title:"6502 Addressing Modes",sidebar_position:3,description:"6502 Addressing Modes"},i="6502 Addressing Modes",o={unversionedId:"G-6502/6502-addressing-modes",id:"G-6502/6502-addressing-modes",title:"6502 Addressing Modes",description:"6502 Addressing Modes",source:"@site/docs/G-6502/6502-addressing-modes.md",sourceDirName:"G-6502",slug:"/G-6502/6502-addressing-modes",permalink:"/SPO600/G-6502/6502-addressing-modes",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/G-6502/6502-addressing-modes.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"6502-addressing-modes",title:"6502 Addressing Modes",sidebar_position:3,description:"6502 Addressing Modes"},sidebar:"courseNotesSidebar",previous:{title:"6502 Emulator",permalink:"/SPO600/G-6502/6502-emulator"},next:{title:"6502 Instructions - Introduction",permalink:"/SPO600/G-6502/6502-instructions-introduction"}},d={},l=[{value:"Accumulator",id:"accumulator",level:2},{value:"Absolute",id:"absolute",level:2},{value:"Absolute, X",id:"absolute-x",level:2},{value:"Absolute, Y",id:"absolute-y",level:2},{value:"Immediate",id:"immediate",level:2},{value:"Implied",id:"implied",level:2},{value:"Indirect",id:"indirect",level:2},{value:"X, Indirect",id:"x-indirect",level:2},{value:"Indirect, Y",id:"indirect-y",level:2},{value:"Relative",id:"relative",level:2},{value:"Zero page",id:"zero-page",level:2},{value:"Zero page, X",id:"zero-page-x",level:2},{value:"Zero page, Y",id:"zero-page-y",level:2}],u={toc:l};function c(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"6502-addressing-modes"},"6502 Addressing Modes"),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502"},"6502")," processor has 13 Addressing Modes (ADD LINK), which affect how the arguments for instructions are accessed."),(0,n.kt)("p",null,"For example, the Load Accumulator ",(0,n.kt)("inlineCode",{parentName:"p"},"LDA")," instruction can load the accumulator from different sources:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA #$05  ; Immediate addressing mode - load the accumulator with the number 5\nLDA $05   ; Zero-page addressing mode - load the accumulator from memory address 5\nLDA $0805 ; Absolute addressing mode - load the accumulator from memory address 0x8005 (32773).\n")),(0,n.kt)("p",null,"Not all addressing modes are valid for every instruction."),(0,n.kt)("h2",{id:"accumulator"},"Accumulator"),(0,n.kt)("p",null,"The operation works on the accumulator. No additional data is required. Examples:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"},"ASL A\nLSR A\nROL A\nROR A\n")),(0,n.kt)("p",null,"Note that the explicit ",(0,n.kt)("inlineCode",{parentName:"p"},"A")," is not required by most assemblers, so you could write:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"},"ASL\nLSR\nROL\nROR\n")),(0,n.kt)("h2",{id:"absolute"},"Absolute"),(0,n.kt)("p",null,"Data is accessed using 16-bit address specified as a constant."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA $06d3\nSTX $0200\nJMP $5913\n")),(0,n.kt)("h2",{id:"absolute-x"},"Absolute, X"),(0,n.kt)("p",null,"Data is accessed using a 16-bit address specified as a constant, to which the value of the X register is added (with carry)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA $8000,x\nSTA $8000,x\n")),(0,n.kt)("h2",{id:"absolute-y"},"Absolute, Y"),(0,n.kt)("p",null,"Data is accessed using a 16-bit address specified as a constant, to which the value of the Y register is added (with carry)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA $8000,y\nSTA $8000,y\n")),(0,n.kt)("h2",{id:"immediate"},"Immediate"),(0,n.kt)("p",null,"Data is taken from the byte following the opcode."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA #$05\nORA #$80\n")),(0,n.kt)("h2",{id:"implied"},"Implied"),(0,n.kt)("p",null,"The data is implied by the operation. Examples:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"CLC ; clears the Carry flag - it's implied that this operates on the Status register\nRTS ; return from subroutine - it's implied that the return address will be taken from the stack\n")),(0,n.kt)("h2",{id:"indirect"},"Indirect"),(0,n.kt)("p",null,"Data is accessed using a pointer. The 16-bit address of the pointer is given in the two bytes following the opcode."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"JMP ($9000) ; Jumps to the location pointed to by addresses $9000 (low) and $9001 (high)\n")),(0,n.kt)("h2",{id:"x-indirect"},"X, Indirect"),(0,n.kt)("p",null,"An 8-bit zero-page address and the X register are added, without carry (if the addition overflows, the address wraps around within page 0). The resulting address is used as a pointer to the data being accessed. Note that, effectively, this makes the X register an index into a list of pointers. Also note that pointers are two bytes long, so the X register should be an even number when accessing a list of pointers (otherwise you'll get half of one pointer and half of another)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA ($05,x) ; if x=4, then the pointer at $09 (and $0a) will be used, and the accumulator loaded from the address indicated by the pointer\n")),(0,n.kt)("h2",{id:"indirect-y"},"Indirect, Y"),(0,n.kt)("p",null,"An 8-bit address identifies a pointer. The value of the Y register is added to the address contained in the pointer. Effectively, the pointer is the base address and the Y register is an index past that base address."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA ($10),y ; if y=4, and the pointer at $10 (and $11) holds the value $FF00, then the accumulator is loaded from the address ($FF00+$04)=$FF04\n")),(0,n.kt)("h2",{id:"relative"},"Relative"),(0,n.kt)("p",null,"An 8-bit signed offset is provided. This value is added to the program counter (PC) to find the effective address."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},'BNE $0600 ; The value "$0600" is assembled into a signed offset (note that $0600 is not the value of the argument in the assembled code -- the offset is a one-byte signed value calculated by the assembler). The target must be in the range of (-128:127) bytes of the current PC value.\n')),(0,n.kt)("h2",{id:"zero-page"},"Zero page"),(0,n.kt)("p",null,"An 8-bit address is provided within the zero page. This is like an absolute address, but since the argument is only one byte, the CPU does not have to spend an additional cycle to fetch high byte."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDX $13\nAND $07\n")),(0,n.kt)("h2",{id:"zero-page-x"},"Zero page, X"),(0,n.kt)("p",null,"An 8-bit address is provided, to which the X register is added (without carry - if the addition overflows, the address wraps around within the zero page)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"STA $00,x\nLDA $00,x\n")),(0,n.kt)("h2",{id:"zero-page-y"},"Zero page, Y"),(0,n.kt)("p",null,"An 8-bit address is provided, to which the Y register is added (without carry - if the addition overflows, the address wraps around within the zero page)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"STA $00,y\nLDA $00,y\n")))}c.isMDXComponent=!0}}]);