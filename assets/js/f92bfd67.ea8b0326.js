"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[6268],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=s(t),h=r,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||o;return t?a.createElement(m,i(i({ref:n},d),{},{components:t})):a.createElement(m,i({ref:n},d))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8824:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return s}});var a=t(3117),r=(t(7294),t(3905));const o={id:"6502-emulator-example-code",title:"6502 Emulator Example Code",sidebar_position:8,description:"6502 Emulator Example Code"},i="6502 Emulator Example Code",l={unversionedId:"G-6502/6502-emulator-example-code",id:"G-6502/6502-emulator-example-code",title:"6502 Emulator Example Code",description:"6502 Emulator Example Code",source:"@site/docs/G-6502/6502-emulator-example-code.md",sourceDirName:"G-6502",slug:"/G-6502/6502-emulator-example-code",permalink:"/SPO600/G-6502/6502-emulator-example-code",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/G-6502/6502-emulator-example-code.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{id:"6502-emulator-example-code",title:"6502 Emulator Example Code",sidebar_position:8,description:"6502 Emulator Example Code"},sidebar:"courseNotesSidebar",previous:{title:"6502 Counting Loop Example",permalink:"/SPO600/G-6502/6502-counting-loop-example"},next:{title:"8x8 Bitmap Patterns for Digits",permalink:"/SPO600/G-6502/8x8-bitmap-patterns-for-digits"}},c={},s=[{value:"Fill the Bitmapped Display",id:"fill-the-bitmapped-display",level:2},{value:"Place a Message on the Character Display",id:"place-a-message-on-the-character-display",level:2},{value:"Without using the ROM routines",id:"without-using-the-rom-routines",level:3},{value:"Using the ROM routines",id:"using-the-rom-routines",level:3},{value:"Type on the Screen",id:"type-on-the-screen",level:2},{value:"Place a Graphic on the Screen",id:"place-a-graphic-on-the-screen",level:2},{value:"Etch-a-Sketchtm Style Drawing",id:"etch-a-sketchtm-style-drawing",level:2},{value:"Additional Examples",id:"additional-examples",level:2}],d={toc:s};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"6502-emulator-example-code"},"6502 Emulator Example Code"),(0,r.kt)("p",null,"This is a collection of simple examples of ",(0,r.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502"},"6502")," ",(0,r.kt)("a",{parentName:"p",href:"/SPO600/F-AssemblyLanguage/assembly-language"},"assembly language")," code which will run in the ",(0,r.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502-emulator"},"6502 Emulator"),". To use this code, copy and paste one of these programs into the text box of the ",(0,r.kt)("a",{parentName:"p",href:"http://6502.cdot.systems/"},"emulator"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This code is Copyright \xa92020-2022 Seneca College of Applied Arts and Technology. Each of these programs is free software; you can redistribute them and/or modify them under the terms of the ",(0,r.kt)("a",{parentName:"strong",href:"https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html%7CGNU"},"General Public License")," as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.")),(0,r.kt)("h2",{id:"fill-the-bitmapped-display"},"Fill the Bitmapped Display"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"      lda #$00     ; set pointer at $10 to $0200\n      sta $10\n      lda #$02\n      sta $11\n      \n      ldx #$06     ; max value for $11, the high byte of the pointer\n      \n      ldy #$00     ; index - this value is added to the pointer\n\n      lda #$07     ; colour code to be used to fill the display\n\nloop: sta ($10),y  ; store colour to the value of the pointer + Y\n      iny          ; increment index - prepare to fill next pixel\n      bne loop     ; branch until page done - stops when Y==0\n      \n      inc $11      ; increment high byte of pointer\n      cpx $11      ; compare with max value\n      bne loop     ; continue if not done \n      \n      brk          ; done - return to debugger\n")),(0,r.kt)("h2",{id:"place-a-message-on-the-character-display"},"Place a Message on the Character Display"),(0,r.kt)("h3",{id:"without-using-the-rom-routines"},"Without using the ROM routines"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},' define SCREEN $f000     ; location of screen memory\n\n           ldy #$00      ; index value (character we\'re currently processing)\n \n char:     lda text,y    ; get a character from address (text + Y)\n           beq done      ; if the character is NULL, branch to done\n           sta SCREEN,y  ; store character at (SCREEN + Y)\n           iny           ; increment Y (go to next character)\n           bne char      ; repeat loop\n \n done:     brk           ; when we\'re done, break (stop the program)\n \n text:                   ; this is the text message\n dcb "6","5","0","2",32,"w","a","s",32,"h","e","r","e",".",00\n')),(0,r.kt)("h3",{id:"using-the-rom-routines"},"Using the ROM routines"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'; ROM routines\ndefine      SCINIT      $ff81 ; initialize/clear screen\ndefine      CHRIN       $ffcf ; input character from keyboard\ndefine      CHROUT      $ffd2 ; output character to screen\ndefine      SCREEN      $ffed ; get screen size\ndefine      PLOT        $fff0 ; get/set cursor coordinates\n\n          jsr SCINIT  ; initialize and clear the screen\n          ldy #$00\n\nchar:     lda text,y\n          beq done\n          jsr CHROUT  ; put the character in A on to the screen\n          iny\n          bne char\n\ndone:     brk\n\ntext:\ndcb "6","5","0","2",32,"w","a","s",32,"h","e","r","e",".",00\n')),(0,r.kt)("h2",{id:"type-on-the-screen"},"Type on the Screen"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"; let the user type on the first page of character screen\n; has blinking cursor!\n; does not use ROM routines\n; backspace works (non-destructive), arrows/ENTER don't\n \nnext:     ldx #$00\nidle:     inx\n          cpx #$10\n          bne check\n          lda $f000,y\n          eor #$80\n          sta $f000,y\n\ncheck:    lda $ff\n          beq idle\n\n          ldx #$00\n          stx $ff\n\n          cmp #$08 ; bs\n          bne print\n\n          lda $f000,y\n          and #$7f\n          sta $f000,y\n\n          dey\n          jmp next\n\nprint:    sta $f000,y\n          iny\n          jmp next\n")),(0,r.kt)("h2",{id:"place-a-graphic-on-the-screen"},"Place a Graphic on the Screen"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"}," define WIDTH   4 ; width of graphic\n define HEIGHT  4 ; height of graphic\n \n \n    lda #$25    ; create a pointer at $10\n    sta $10     ;   which points to where\n    lda #$02    ;   the graphic should be drawn\n    sta $11\n \n    lda #$00    ; number of rows we've drawn\n    sta $12     ;   is stored in $12\n \n    ldx #$00    ; index for data\n    ldy #$00    ; index for screen column\n \n draw:  lda data,x\n    sta ($10),y\n    inx\n    iny\n    cpy #WIDTH\n    bne draw\n   \n    inc $12     ; increment row counter\n \n    lda #HEIGHT ; are we done yet?\n    cmp $12\n    beq done    ; ...exit if we are\n \n    lda $10     ; load pointer\n    clc\n    adc #$20    ; add 32 to drop one row\n    sta $10\n    lda $11         ; carry to high byte if needed\n    adc #$00\n    sta $11\n \n    ldy #$00\n    beq draw\n \n done:  brk     ; stop when finished\n \n data:                 ; graphic to be displayed\n dcb 00,03,03,00\n dcb 07,00,00,07\n dcb 07,00,00,07\n dcb 00,03,03,00\n")),(0,r.kt)("h2",{id:"etch-a-sketchtm-style-drawing"},"Etch-a-Sketchtm Style Drawing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},'; zero-page variable locations\ndefine  ROW     $20 ; current row\ndefine  COL     $21 ; current column\ndefine  POINTER     $10 ; ptr: start of row\ndefine  POINTER_H   $11\n\n; constants\ndefine  DOT     $01 ; dot colour\ndefine  CURSOR      $04 ; black colour\n\n\n        ldy #$00    ; put help text on screen\nprint:      lda help,y\n        beq setup\n        sta $f000,y\n        iny\n        bne print\n\nsetup:      lda #$0f    ; set initial ROW,COL\n        sta ROW\n        sta COL\n\ndraw:       lda ROW     ; ensure ROW is in range 0:31\n        and #$1f\n        sta ROW\n\n        lda COL     ; ensure COL is in range 0:31\n        and #$1f\n        sta COL\n\n        ldy ROW     ; load POINTER with start-of-row\n        lda table_low,y\n        sta POINTER\n        lda table_high,y\n        sta POINTER_H\n\n        ldy COL     ; store CURSOR at POINTER plus COL\n        lda #CURSOR\n        sta (POINTER),y\n\ngetkey:     lda $ff     ; get a keystroke\n        beq getkey\n\n        ldx #$00    ; clear out the key buffer\n        stx $ff\n\n        cmp #$43    ; handle C or c\n        beq clear\n        cmp #$63\n        beq clear\n\n        cmp #$80    ; if not a cursor key, ignore\n        bmi getkey\n        cmp #$84\n        bpl getkey\n\n        pha     ; save A\n\n        lda #DOT    ; set current position to DOT\n        sta (POINTER),y\n\n        pla     ; restore A\n\n        cmp #$80    ; check key == up\n        bne check1\n\n        dec ROW     ; ... if yes, decrement ROW\n        jmp done\n\ncheck1:     cmp #$81    ; check key == right\n        bne check2\n\n        inc COL     ; ... if yes, increment COL\n        jmp done\n\ncheck2:     cmp #$82    ; check if key == down\n        bne check3\n\n        inc ROW     ; ... if yes, increment ROW\n        jmp done\n\ncheck3:     cmp #$83    ; check if key == left\n        bne done\n\n        dec COL     ; ... if yes, decrement COL\n        clc\n        bcc done\n\nclear:      lda table_low   ; clear the screen\n        sta POINTER\n        lda table_high\n        sta POINTER_H\n\n        ldy #$00\n        tya\n\nc_loop:     sta (POINTER),y\n        iny\n        bne c_loop\n\n        inc POINTER_H\n        ldx POINTER_H\n        cpx #$06\n        bne c_loop\n\ndone:       clc     ; repeat\n        bcc draw\n\n\n; these two tables contain the high and low bytes\n; of the addresses of the start of each row\n\ntable_high:\ndcb $02,$02,$02,$02,$02,$02,$02,$02\ndcb $03,$03,$03,$03,$03,$03,$03,$03\ndcb $04,$04,$04,$04,$04,$04,$04,$04\ndcb $05,$05,$05,$05,$05,$05,$05,$05,\n\ntable_low:\ndcb $00,$20,$40,$60,$80,$a0,$c0,$e0\ndcb $00,$20,$40,$60,$80,$a0,$c0,$e0\ndcb $00,$20,$40,$60,$80,$a0,$c0,$e0\ndcb $00,$20,$40,$60,$80,$a0,$c0,$e0\n\n; help message for the character screen\n\nhelp:\ndcb "A","r","r","o","w",32,"k","e","y","s"\ndcb 32,"d","r","a","w",32,"/",32,"\'","C","\'"\ndcb 32,"k","e","y",32,"c","l","e","a","r","s"\ndcb 00\n')),(0,r.kt)("h2",{id:"additional-examples"},"Additional Examples"),(0,r.kt)("p",null,"Additional examples, as well as the source code for the emulator's ROM routines, are in a repository at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ctyler/6502js-code"},"https://github.com/ctyler/6502js-code")))}p.isMDXComponent=!0}}]);