"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[6586],{3905:function(e,t,i){i.d(t,{Zo:function(){return c},kt:function(){return p}});var r=i(7294);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,r)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function l(e,t){if(null==e)return{};var i,r,n=function(e,t){if(null==e)return{};var i,r,n={},a=Object.keys(e);for(r=0;r<a.length;r++)i=a[r],t.indexOf(i)>=0||(n[i]=e[i]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)i=a[r],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}var s=r.createContext({}),u=function(e){var t=r.useContext(s),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},c=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var i=e.components,n=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=u(i),p=n,f=h["".concat(s,".").concat(p)]||h[p]||d[p]||a;return i?r.createElement(f,o(o({ref:t},c),{},{components:i})):r.createElement(f,o({ref:t},c))}));function p(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=i.length,o=new Array(a);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,o[1]=l;for(var u=2;u<a;u++)o[u]=i[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,i)}h.displayName="MDXCreateElement"},3527:function(e,t,i){i.r(t),i.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return a},metadata:function(){return l},toc:function(){return u}});var r=i(3117),n=(i(7294),i(3905));const a={id:"6502-math",title:"6502 Math",sidebar_position:5,description:"6502 Math"},o="6502 Math",l={unversionedId:"G-6502/6502-math",id:"G-6502/6502-math",title:"6502 Math",description:"6502 Math",source:"@site/docs/G-6502/6502-math.md",sourceDirName:"G-6502",slug:"/G-6502/6502-math",permalink:"/SPO600/G-6502/6502-math",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/G-6502/6502-math.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"6502-math",title:"6502 Math",sidebar_position:5,description:"6502 Math"},sidebar:"courseNotesSidebar",previous:{title:"6502 Instructions - Introduction",permalink:"/SPO600/G-6502/6502-instructions-introduction"},next:{title:"6502 Jumps, Branches, and Procedures",permalink:"/SPO600/G-6502/6502-jumps-branches-and-procedures"}},s={},u=[{value:"Decimal Mode",id:"decimal-mode",level:2},{value:"Addition",id:"addition",level:2},{value:"Subtraction",id:"subtraction",level:2},{value:"Division / LSR",id:"division--lsr",level:2},{value:"Multiplication / ASL",id:"multiplication--asl",level:2},{value:"Rotate Right/Left",id:"rotate-rightleft",level:2},{value:"Bitwise Operations",id:"bitwise-operations",level:2}],c={toc:u};function d(e){let{components:t,...i}=e;return(0,n.kt)("wrapper",(0,r.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"6502-math"},"6502 Math"),(0,n.kt)("p",null,"The 6502 processor is limited to very simple math operations, and various processor flags affect these operations."),(0,n.kt)("h2",{id:"decimal-mode"},"Decimal Mode"),(0,n.kt)("p",null,"The 6502 can perform math in binary or decimal mode."),(0,n.kt)("p",null,"In binary mode, operations are performed on a single 8-bit value. Numbers may be treated as signed or unsigned (the math is the same)."),(0,n.kt)("p",null,"In decimal mode, the each byte is treated as two decimal digits - the lower 4 bits represent the lower digit, and the upper 4 bits represent the upper digit. Numbers are counted as positive, and values greater than 9 are invalid."),(0,n.kt)("p",null,"Decimal mode is selected by setting the D flag in the ",(0,n.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502#registers"},"Status Register")," using the ",(0,n.kt)("inlineCode",{parentName:"p"},"SED")," instruction, and binary mode is selected by clearing the D flag using the ",(0,n.kt)("inlineCode",{parentName:"p"},"CLD")," instruction."),(0,n.kt)("p",null,"The rest of this page deals with binary mode (decimal mode operates in mostly the same way)."),(0,n.kt)("h2",{id:"addition"},"Addition"),(0,n.kt)("p",null,"The ADC (add with carry) instruction adds together:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"},"the value in the accumulator + the specified byte + the carry flag\n")),(0,n.kt)("p",null,"If the unsigned value overflows a single byte, the carry flag will be set."),(0,n.kt)("p",null,"It is therefore important to clear the carry flag (with ",(0,n.kt)("inlineCode",{parentName:"p"},"CLC"),") before adding the lowest byte of a single or multi-byte value. If a multi-byte addition is performed starting with the lowest byte and proceeding to the highest byte, the carry flag will correctly carry bits forward from one byte to the next. For example, this code adds $30F0 and $0120:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-assembly"},"LDA #$F0      ; A=$F0\nCLC           ; C=0\nADC #$20      ; Result is $F0+$20+C = $110; therefore A=$10 and C=1\nSTA LOWBYTE\nLDA #$30      ; A=$30\nADC #$01      ; Value is $30+$01+C = $32; therefore A=$32 and C=0\nSTA HIGHBYTE\n")),(0,n.kt)("p",null,"The Overflow (V) flag is set if the signed result of the operation is above 127 ($7f) or below -128 ($80)."),(0,n.kt)("h2",{id:"subtraction"},"Subtraction"),(0,n.kt)("p",null,"The SBC (subtract with carry) operation subtracts:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"},"the value in the accumulator - the specified byte - (not Carry)\n")),(0,n.kt)("p",null,"Where the ",(0,n.kt)("inlineCode",{parentName:"p"},"not")," operation inverts the value of the carry flag."),(0,n.kt)("p",null,'The carry flag (which can be viewed as a "borrow" flag for subtraction) is cleared if the result underflows $00 and set otherwise (in other words, if doing unsigned math, the Carry flag is cleared if a bit must be "borrowed").'),(0,n.kt)("p",null,"Normally, you will set the carry flag (with ",(0,n.kt)("inlineCode",{parentName:"p"},"SEC"),") before performing a subtraction on the lowest byte of a single- or multi-byte subtraction, and then perform subtraction on each byte in sequence up to the highest byte. The borrows will automatically be carried from one byte to the next."),(0,n.kt)("p",null,"The Overflow (V) flag is set if the signed result of the operation is above 127 ($7f) or below -128 ($80)."),(0,n.kt)("h2",{id:"division--lsr"},"Division / LSR"),(0,n.kt)("p",null,"There is no general division operation available. However, Logical Shift Right will effectively perform a division-by-two. A zero will be rotated into the highest bit, and the lowest bit will be shifted into the Carry flag (C)."),(0,n.kt)("h2",{id:"multiplication--asl"},"Multiplication / ASL"),(0,n.kt)("p",null,"There is no general multiplication operation available. However, Arithmetic Shift Left will effectively perform a multiplication-by-two. A zero will be rotated into the lowest bit, and highest bit will be shifted into the Carry flag (C)."),(0,n.kt)("h2",{id:"rotate-rightleft"},"Rotate Right/Left"),(0,n.kt)("p",null,"The Rotate Right and Rotate Left (ROR/ROL) instructions are like the LSR/ASL instructions, except that the Carry flag is rotated into one end of the byte, and the bit from the other end is rotated into the Carry flag. For example, ROR will shift C into the high bit and the low bit into C. Therefore, it is possible to perform a multi-byte rotate by stringing together ROR or ROL instructions."),(0,n.kt)("h2",{id:"bitwise-operations"},"Bitwise Operations"),(0,n.kt)("p",null,"The 6502 offers a basic set of ",(0,n.kt)("a",{parentName:"p",href:"/SPO600/E-ComputerArchitecture/bitwise-operations"},"Bitwise Operations"),", including:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"}," ROR  Rotate right - 9-bit rotate (one byte plus C flag)\n ROL  Rotate left - 9-bit rotate left (one byte plus C flag)\n ASL  Arithmetic shift left - bit 7 -> C flag, bits 0:6 -> 1:7, 0 -> bit 0\n LSR  Logical shift right - bit 0 -> C flag, bits 7:1 -> 6:0, 0 -> bit 7\n EOR  Exclusive-OR (synonym for XOR)\n ORA  OR (accumulator)\n AND  AND\n")),(0,n.kt)("p",null,"A NOT operation can be performed using EOR with an immediate value of #$FF, and this can be combined with ORA and AND instructions to build NOR and NAND operations."),(0,n.kt)("p",null,"The BIT instruction performs a bitwise AND, sets the Z flag based on the result, and transfers bits 6 and 7 of the operand into the N and V flags."))}d.isMDXComponent=!0}}]);