"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[8283],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return d}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),c=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(a),d=r,h=p["".concat(o,".").concat(d)]||p[d]||m[d]||s;return a?n.createElement(h,l(l({ref:t},u),{},{components:a})):n.createElement(h,l({ref:t},u))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,l=new Array(s);l[0]=p;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var c=2;c<s;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},2577:function(e,t,a){a.r(t),a.d(t,{assets:function(){return o},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return i},toc:function(){return c}});var n=a(3117),r=(a(7294),a(3905));const s={id:"syscalls",title:"Syscalls",sidebar_position:6,description:"Syscalls"},l="Syscalls",i={unversionedId:"F-AssemblyLanguage/syscalls",id:"F-AssemblyLanguage/syscalls",title:"Syscalls",description:"Syscalls",source:"@site/docs/F-AssemblyLanguage/syscalls.md",sourceDirName:"F-AssemblyLanguage",slug:"/F-AssemblyLanguage/syscalls",permalink:"/SPO600/F-AssemblyLanguage/syscalls",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/F-AssemblyLanguage/syscalls.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"syscalls",title:"Syscalls",sidebar_position:6,description:"Syscalls"},sidebar:"courseNotesSidebar",previous:{title:"Symbol",permalink:"/SPO600/F-AssemblyLanguage/symbol"},next:{title:"AArch64 Register and Instruction Quick Start",permalink:"/SPO600/F-AssemblyLanguage/aarch64-register-and-instruction-quick-start"}},o={},c=[{value:"Syscall Mechanism",id:"syscall-mechanism",level:2},{value:"x86 32-bit",id:"x86-32-bit",level:3},{value:"x86 64-bit",id:"x86-64-bit",level:3},{value:"aarch64",id:"aarch64",level:3},{value:"Syscall names, numbers, and arguments",id:"syscall-names-numbers-and-arguments",level:2},{value:"Syscall names",id:"syscall-names",level:3},{value:"Syscall numbers",id:"syscall-numbers",level:3},{value:"Syscall arguments and return values",id:"syscall-arguments-and-return-values",level:3},{value:"Using the syscall number macro definitions in asm code",id:"using-the-syscall-number-macro-definitions-in-asm-code",level:2}],u={toc:c};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"syscalls"},"Syscalls"),(0,r.kt)("p",null,"The system call (",(0,r.kt)("em",{parentName:"p"},"syscall"),") mechanism is used by applications to access kernel services. The userland (application/non-kernel) program loads certain registers designating the system service (syscall) desired and the arguments to that syscall, then invokes a software ",(0,r.kt)("a",{parentName:"p",href:"/SPO600/E-ComputerArchitecture/computer-architecture#interrupts-and-exceptions"},"interrupt")," or exception request which transfers control to the operating system kernel. Note that switching to kernel mode requires a change of ",(0,r.kt)("a",{parentName:"p",href:"/SPO600/E-ComputerArchitecture/computer-architecture#execution-state-priviledge-state-rings-or-privilege-level"},"processor mode")," (sometimes call the privilege level or exception level), because the kernel has access to instructions, memory structures, memory areas, and devices which userland programs can't access. The syscall numbers may vary between architectures, and the registers as well as the method used to invoke syscalls are architecture-specific. The processor modes and activity involved in a userland-to-kernel switch also vary by architecture."),(0,r.kt)("p",null,"High-level languages wrap the syscall interface in basic wrappers or more advanced mechanisms. For example, in C, the ",(0,r.kt)("em",{parentName:"p"},"write")," syscall can be accessed through the generic ",(0,r.kt)("inlineCode",{parentName:"p"},"syscall")," wrapper, the ",(0,r.kt)("inlineCode",{parentName:"p"},"write()")," wrapper, or through more complex functions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"printf()"),". ",(0,r.kt)("a",{parentName:"p",href:"/SPO600/F-AssemblyLanguage/assembly-language"},"Assembly language")," programs will often access syscalls directly."),(0,r.kt)("h2",{id:"syscall-mechanism"},"Syscall Mechanism"),(0,r.kt)("p",null,"Every platform has a different syscall mechanism. Each mechanism is documented in the ABI standards for that platform, and a summary of various platforms is contained in the manpage for syscall(2) (run the command ",(0,r.kt)("inlineCode",{parentName:"p"},"man 2 syscall")," to see this)."),(0,r.kt)("p",null,"To invoke a syscall in your own code, load the syscall number and arguments into the appropriate registers, and then invoke the architecture-specific syscall mechanism, using the details below:"),(0,r.kt)("h3",{id:"x86-32-bit"},"x86 32-bit"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The syscall number is placed in eax."),(0,r.kt)("li",{parentName:"ul"},"Integer and pointer arguments are placed in edi, esi, edx, ecx with spill over to the stack (refer to ABI documentation)."),(0,r.kt)("li",{parentName:"ul"},"Return value is in eax."),(0,r.kt)("li",{parentName:"ul"},"The syscall is invoked with ",(0,r.kt)("inlineCode",{parentName:"li"},"int 0x80"))),(0,r.kt)("h3",{id:"x86-64-bit"},"x86 64-bit"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The syscall number is placed in rax."),(0,r.kt)("li",{parentName:"ul"},"Integer and pointer arguments are placed in rdi, rsi, rdx, rcx, r8d, r9d with spill over to the stack (refer to ABI documentation)."),(0,r.kt)("li",{parentName:"ul"},"Return value is in rax."),(0,r.kt)("li",{parentName:"ul"},"The syscall is invoked with ",(0,r.kt)("inlineCode",{parentName:"li"},"syscall"))),(0,r.kt)("h3",{id:"aarch64"},"aarch64"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The syscall number is placed in r8."),(0,r.kt)("li",{parentName:"ul"},"Integer and pointer arguments are placed in r0-r7 with spill over to the stack (refer to Procedure Call and ABI documentation)."),(0,r.kt)("li",{parentName:"ul"},"Return value is in r0."),(0,r.kt)("li",{parentName:"ul"},"The syscall is invoked with ",(0,r.kt)("inlineCode",{parentName:"li"},"svc 0"))),(0,r.kt)("h2",{id:"syscall-names-numbers-and-arguments"},"Syscall names, numbers, and arguments"),(0,r.kt)("h3",{id:"syscall-names"},"Syscall names"),(0,r.kt)("p",null,"A list of syscalls can be found in the manpage for ",(0,r.kt)("inlineCode",{parentName:"p"},"syscalls(2)")," (note: this is different from the manpage for ",(0,r.kt)("inlineCode",{parentName:"p"},"syscall(2)")," which is a generic syscall wrapper). View this with the command ",(0,r.kt)("inlineCode",{parentName:"p"},"man 2 syscalls")),(0,r.kt)("p",null,"Documentation for the C wrappers for most syscalls can be found in the manpage for that wrapper, usually in section 2 of the manual (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"write(2)"),", which is accessed using the command ",(0,r.kt)("inlineCode",{parentName:"p"},"man 2 write"),")."),(0,r.kt)("h3",{id:"syscall-numbers"},"Syscall numbers"),(0,r.kt)("p",null,"Syscall numbers are defined in <asm/unistd.h",">"," (",(0,r.kt)("inlineCode",{parentName:"p"},"/usr/include/asm/unistd.h"),"). If you examine this file, you'll find that it includes different files depending on the platform, because the syscall numbers are platform-specific (on newer platforms, there has been an attempt to use consistent syscall numbers). In this included file, you will find macros for each syscall named ",(0,r.kt)("inlineCode",{parentName:"p"},"__NR_syscall")," which identifies the number for each syscall. For example, aarch64 includes the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/usr/include/asm-generic/unistd.h"),", which lists this macro for the ",(0,r.kt)("em",{parentName:"p"},"write")," syscall:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#define __NR_write 64\n")),(0,r.kt)("p",null,"But on x86_64 the macro definition is taken from ",(0,r.kt)("inlineCode",{parentName:"p"},"/usr/include/asm/unistd_64.h"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#define __NR_write 1\n")),(0,r.kt)("p",null,"You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ausyscall")," utility, which part of the Linux ",(0,r.kt)("em",{parentName:"p"},"audit")," package, to determine the number for a given syscall on the particular platform:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"$ ausyscall x86_64 write\nwrite              1\npwrite             18\nwritev             20\npwritev            296\nprocess_vm_writev  311\n\n$ ausyscall aarch64 write\nwrite              64\nwritev             66\npwrite             68\npwritev            70\nprocess_vm_writev  271\n")),(0,r.kt)("p",null,'Note that the syscall table is searched by name, and in the examples above the text "write" matches five different syscalls. The architecture defaults to the current platform if not specified.'),(0,r.kt)("h3",{id:"syscall-arguments-and-return-values"},"Syscall arguments and return values"),(0,r.kt)("p",null,"The details of each syscall's arguments and return value are listed in <unistd.h",">"," (",(0,r.kt)("inlineCode",{parentName:"p"},"/usr/include/unistd.h"),") in a combination of comments and C extern declarations.For example, for the ",(0,r.kt)("em",{parentName:"p"},"write")," syscall:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"/* Write N bytes of BUF to FD.  Return the number written, or -1.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t write (int __fd, const void *__buf, size_t __n) __wur;\n")),(0,r.kt)("p",null,"This documents that the ",(0,r.kt)("em",{parentName:"p"},"write")," syscall takes three arguments: the file descriptor, a pointer to the message buffer, and the message size, and returns the number of bytes written or -1 if there was an error."),(0,r.kt)("h2",{id:"using-the-syscall-number-macro-definitions-in-asm-code"},"Using the syscall number macro definitions in asm code"),(0,r.kt)("p",null,"The syscall macros can be used in an assembly program if that program is processed by the C preprocessor (cpp). The extension ",(0,r.kt)("inlineCode",{parentName:"p"},".S")," (uppercase instead of lowercase) is used to designate an assembler source file that must be processed by cpp."),(0,r.kt)("p",null,"There are two ways to do this for a pure assembler source file:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Invoke cpp explicitly:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"cpp foo.S > foo.s\nas foo.s -o foo.o\nld foo.o -o foo\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Use ",(0,r.kt)("em",{parentName:"li"},"gcc")," to invoke the assembler and linker:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"gcc foo.S -o foo\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Initialization Code and Entry Point:")," When the assembler is invoked through gcc, C initialization code is inserted into the binary, which increases its size. This initialization uses the entry point ",(0,r.kt)("inlineCode",{parentName:"p"},"_start")," and expects your code to have the entry point ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),"."),(0,r.kt)("p",null,"Using either of these approaches, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"__NR_xxxx")," macros in your assembler code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"#include <asm/unistd.h>\n...\n        mov $__NR_write,%rax\n")))}m.isMDXComponent=!0}}]);