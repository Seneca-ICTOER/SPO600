"use strict";(self.webpackChunkSPO600=self.webpackChunkSPO600||[]).push([[3029],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return h}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(r),h=a,m=d["".concat(c,".").concat(h)]||d[h]||p[h]||s;return r?n.createElement(m,o(o({ref:t},u),{},{components:r})):n.createElement(m,o({ref:t},u))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,o=new Array(s);o[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var l=2;l<s;l++)o[l]=r[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},2122:function(e,t,r){r.r(t),r.d(t,{assets:function(){return c},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return s},metadata:function(){return i},toc:function(){return l}});var n=r(3117),a=(r(7294),r(3905));const s={id:"6502-jumps-branches-and-procedures",title:"6502 Jumps, Branches, and Procedures",sidebar_position:6,description:"6502 Jumps, Branches, and Procedures"},o="6502 Jumps, Branches, and Procedures",i={unversionedId:"G-6502/6502-jumps-branches-and-procedures",id:"G-6502/6502-jumps-branches-and-procedures",title:"6502 Jumps, Branches, and Procedures",description:"6502 Jumps, Branches, and Procedures",source:"@site/docs/G-6502/6502-jumps-branches-and-procedures.md",sourceDirName:"G-6502",slug:"/G-6502/6502-jumps-branches-and-procedures",permalink:"/SPO600/G-6502/6502-jumps-branches-and-procedures",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/SPO600/tree/main/docs/G-6502/6502-jumps-branches-and-procedures.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"6502-jumps-branches-and-procedures",title:"6502 Jumps, Branches, and Procedures",sidebar_position:6,description:"6502 Jumps, Branches, and Procedures"},sidebar:"courseNotesSidebar",previous:{title:"6502 Math",permalink:"/SPO600/G-6502/6502-math"},next:{title:"6502 Counting Loop Example",permalink:"/SPO600/G-6502/6502-counting-loop-example"}},c={},l=[{value:"Jumps",id:"jumps",level:2},{value:"Branches",id:"branches",level:2},{value:"Procedures",id:"procedures",level:2}],u={toc:l};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"6502-jumps-branches-and-procedures"},"6502 Jumps, Branches, and Procedures"),(0,a.kt)("p",null,"Very few computer programs are perfectly lineary in their instruction sequence - the sequence of instructions executed may be repeated (loops), conditional (if/then/else), and involve procedures (aka subroutines, functions, or methods)."),(0,a.kt)("p",null,"On the 6502 processor, there are three main ways to move to a specific code location in memory: jumps, branches, and procedures (or subroutines)."),(0,a.kt)("h2",{id:"jumps"},"Jumps"),(0,a.kt)("p",null,"Jumps are unconditional and cause the program counter to move to a particular address. The instruction is JMP both relative and absolute ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502-addressing-modes"},"addressing modes")," are available."),(0,a.kt)("p",null,"Here is an example using the absolute addressing mode:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"JMP $f027  ; unconditional jump to absolute address\n")),(0,a.kt)("p",null,"This will cause the ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502#registers"},"program counter"),' (PC) to be loaded with the value $f027, causing the processor to execute the instruction at that address next. This is effectively a "GOTO".'),(0,a.kt)("p",null,"This example uses indirect addressing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"JMP ($6094)\n")),(0,a.kt)("p",null,"This loads the PC with the value in memory at $6094:$6095. Effectively, $6094 is a pointer to the address of the next instruction to be executed."),(0,a.kt)("h2",{id:"branches"},"Branches"),(0,a.kt)("p",null,"Branches are conditional on the state of a ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502#registers"},"processor flag"),". The destination of the branch is given as a signed byte relative to the current value of the ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502#registers"},"PC"),", so the destination must be within -128 to +127 bytes of the byte after the branch instruction. These are the branch instructions available:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"BCC ; Branch on Carry flag (C) Clear\nBCS ; Branch on Carry flag (C) Set \nBEQ ; Branch on EQual (zero Z flag set)\nBNE ; Branch on Not Equal (zero Z flag clear)\nBMI ; Branch on MInus (negative flag S/N set)\nBPL ; Branch on PLus (negative flag S/N clear)\nBVC ; Branch on oVerflow flag V Clear\nBVS ; Branch on oVerflow flag V Set\n")),(0,a.kt)("p",null,"In assembler, you typically specify the address or label to which you wish to branch, and the assembler calculates the relative value for the branch offset."),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"LOOP: STA (POINTER),Y\n      INY\n      BNE LOOP\n")),(0,a.kt)("p",null,"In this code, the ",(0,a.kt)("inlineCode",{parentName:"p"},"BNE LOOP")," line is assembled as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"d0 fb     ; BNE $0600\n")),(0,a.kt)("p",null,"Where $FB represents -5 in ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/E-ComputerArchitecture/signed#twos-compliment"},"two's compliment")," notation, since the processor needs to branch back 5 bytes from the current PC location (which is the byte after the end of the BNE instruction)."),(0,a.kt)("p",null,"Because branches are always relative, code that uses only branches is called Position Independent Code (PIC) and can be easily relocated in memory. Therefore, some programmers prefer to use a forced branch instead of a jump, using an approach like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"CLC ; clear the carry flag\nBCC SOMEWHERE ; branch if carry clear (which will always be the case because of the previous line)\n")),(0,a.kt)("p",null,"Although not included in the basic/original 6502, some newer variants of this processor (such as the ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/WDC_65C02"},"65C02"),") have a BRanch Always (BRA) instruction which performs an unconditional relative branch."),(0,a.kt)("h2",{id:"procedures"},"Procedures"),(0,a.kt)("p",null,"Proedures - also called subroutines, functions, or methods - are a special case, because the program flow needs to return to the calling code when the procedure has finished."),(0,a.kt)("p",null,"In the 6502, the JSR (Jump to SubRoutine) instruction is used to push the current value of the ",(0,a.kt)("a",{parentName:"p",href:"/SPO600/G-6502/6502#registers"},"program counter")," on the stack, and then perform an unconditional jump to the address specified (using the absolute addressing mode):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-assembly"},"JSR $F000\n")),(0,a.kt)("p",null,"To return from the procedure, the RTS (ReTurn from Subroutine) instruction loads the PC from the stack, causing execution to continue at the instruction immediately after the JSR."),(0,a.kt)("p",null,"Note that in assembly language, return values can be passed back to the calling function in registers or through stored values. In practical terms, the way that values are returned will depend on the type of data - for example, strings will generally be passed back in memory, while small integers or pointers can be passed in registers."),(0,a.kt)("p",null,"Note also that at the machine language level, there is no distinction between functions, methods, subroutines, and procedures - these distinctions apply only at the source code level and disappear during compilation to machine language."))}p.isMDXComponent=!0}}]);